# Web3 GO [[{dev_framework.go,10_EVM.events,01_PM.WiP]]

## ethclient pkg: [[{]]
- Library to connect clients to nodes (ws/http/ipc)
@[https://medium.com/coinmonks/web3-go-part-1-31c68c68e20e]

  cl, err := ethclient.Dial(“/tmp/geth.ipc”)          // Ex.1:  Use local node
                                                      // (or http://$IP:$PORT for remote node)
                                                      // cl wraps a raw rpc.Client

  infura := “wss://goerli.infura.io/ws/v3/xxxxxx”     // Ex.2: Use infura
  cl, err := ethclient.Dial(infura)
  //
  ctx := context.Background()               ← Retrieve a block by number
  block, err := cl.BlockByNumber(
                   ctx, big.NewInt(123))
  //
  addr := common.HexToAddress("0xb02A2...") ← Get Balance of an account (nil means at newest block)
  balance, err := cl.BalanceAt(ctx, addr, nil)
  //
  tx := new(types.Transaction)
  err = cl.SendTransaction(ctx, tx)         ← Send transaction: It will fail. tx is unsigned&empty
  //
  progress, err := cl.SyncProgress(ctx)     ← Get sync progress for node

## accounts package
  Ex. Create raw transaction.
  nonce, err := cl.NonceAt(ctx, addr, nil)   ← Retrieve the pending nonce for an account
  to  := common.HexToAddress("0xABCD")
  amount := big.NewInt(10 * params.GWei)
  gasLimit := uint64(21000)
  gasPrice := big.NewInt(10 * params.GWei)
  data := []byte{}
  tx := types.NewTransaction(nonce,          ← Create new raw unsigned transaction
     to, amount, gasLimit, gasPrice, data)

                                               Sign TX with in-memory priv.key
                                               ===============================
  PK := "0x..."                              ← (p)rivate (K)ey as hex.formated string
  pk := crypto.ToECDSAUnsafe(                ← convert hex.string to ECDSA private key
            common.FromHex(PK))
  signedTx, err := types.SignTx(tx,          ← Sign tx (Discourages, better use the
          types.NewEIP155Signer(nil), pk)      TransactOpts object).
  addr := crypto.PubkeyToAddress(            ← ex. Obtain public key from private key.
          pk.PublicKey)
  opts := bind.NewKeyedTransactor(pk)        ← ex. create TransactOpts object from
                                               in-memory priv.key

                                               Sign TX with offchain wallet/keystore
                                               ===============================
  ks := keystore.NewKeyStore(".../keystore", ← Open Keystore
        keystore.StandardScryptN,
        keystore.StandardScryptP)
  acc, err := ks.NewAccount("password")      ← Create an account in key Store
  accs := ks.Accounts()                      ← List all accounts in Key Store
  ks.Unlock(accs[0], "password")             ← Unlock account[0]
  ksOpts, err := bind.NewKeyStoreTransactor  ← Create TransactOpts object.
                 (ks, accs[0])
  sigTx, err := ksOpts.Signer(               ← Use it to sign TXs.
    types.NewEIP155Signer(nil),                TransactOpts Also needed to interact
    senderAddr, tx)                             with S.C. using auto-generated bindings.
[[}]]

## bind/abigen [[{]]
- Package to interact with Smart Contracts
@[https://medium.com/coinmonks/web3-go-part-2-aebdcb8d926e]
  It avoid to interact manually with ABI.
* abigen, (included in full installation of geth)
    $ abigen --pkg coolcontract \
      --sol CoolContract.sol  \               ← Input solidity contract.
     --out ./coolcontract/CoolContract.go     ← autogenerates (lot of useful) methods to deploy
                                                and interact with the contract.
* For any interaction we need an Object implementing <<ContractBackend>>.
   backend, err := ethclient.Dial("/tmp/geth.ipc") ← returns ethclient.Client implementing
                                                     <<ContractBackend>>
   addr := common.HexToAddress("0x0..")            ← deployed S.C. address as hex.string
   ctr, err := contract.NewContract(addr, backend) ← Bind to already deployed contract
                                                     (contract: generated by abigen)
                                                     To deploy new contract instead:
                                                     addr, tx, ctr, err :=
                                                         coolcontract.DeployCoolContract(
                                                             transactOpts, backend)
                                                     _, err = bind.WaitDeployed(ctx, backend, tx)

   callOpts := &bind.CallOpts{
                  Context: ctx, Pending: false
               }
   bal, err := ctr.SeeBalance(callOpts)           ← Call pure/view (read-only) function.
                                                    no mining needed.
   tx, err := ctr.Deposit(transactOpts)           ← Execute transaction (mining needed)
   receipt, err := bind.WaitMined(ctx, backend, tx)
   if receipt.Status != types.ReceiptStatusSuccessful {
     panic("Call failed")
   }
[[}]]

## Event listening [[{]]
@[https://medium.com/coinmonks/intro-to-web3-go-part-3-d4f08a32c0ae]
  └ filtering for (OLD!!!) events: (abigen autogenerated Filter<EventName> )
      create bind.FilterOpts with start/end block arguments.
      WARN: only works on full (archive) nodes.
      WARN: It does not work on Infura.
     filOpt := &bind.FilterOpts{              ← Indicate start/end block
                 Context: ctx,
                 Start: 9000000,              ← Tune start/end to avoid DoS on node.
                 End: nil
               }
     itr, err := ctr.FilterDeposited(filOpt)  ← Filter"EventName" Autogenerated by 'abigen'
     for itr.Next() {
         event := itr.Event
         fmt.Printf(event.Addr.Hex())
     }
  └ listening for (FUTURE!!!) events:
    watchOpts := &bind.WatchOpts{
                    Context: ctx,
                    Start: nil
                 }
    channel := make(chan               ← STEP 1) Setup (async) channel for (FUTURE) results
       * coolcontract.CoolContractDeposited)
    go func() {                        ← STEP 2) Start goroutine listening for events
       sub, err := ctr.WatchDeposited( ← Watch"EventName" autogenerated by 'abigen'
          watchOpts, channel)
        defer sub.Unsubscribe()
    }()
    event := <-channel                 ← Receive events from channel

   TIP: to retrieve both historical and future events,
        create subscription goroutine BEFORE filtering old states.
        Wait for a bit so you’re certain it gets scheduled.
        WARN: otherwise you might loose events.

   └ parsing events from types.Log  (useful in some scenarios): (TODO)
     log := * new(types.Log)
     event, err := ctr.ParseDeposited(log)
[[}]]

## TESTING  [[{]]
- using go-ethereum as a library

@[https://medium.com/coinmonks/intro-to-web3-go-part-4-5a21bc71fddc]
  low-code simulated blockchain for unit tests embedded in go-etherum.

  (accounts/abi/bind/backends/)backends.SimulatedBackend implement
  <<ContractBackend>> (replacing ethclient.Client node connection).

  backend := backends.NewSimulatedBackend(
             core.DefaultGenesisBlock().Alloc,
             9000000)
  bal, err := backend.BalanceAt(
              ctx, common.HexToAddress("0x.."), nil)

  faucetSK, err := crypto.GenerateKey()
  faucetAddr := crypto.PubkeyToAddress(faucetSK.PublicKey)
  addr := map[common.Address]core
       .GenesisAccount{
          common.BytesToAddress([]byte{1}):
            {Balance: big.NewInt(1)}, // ECRecover   precompiles
          common.BytesToAddress([]byte{2}):
            {Balance: big.NewInt(1)}, // SHA256      precompiles
          common.BytesToAddress([]byte{3}):
            {Balance: big.NewInt(1)}, // RIPEMD      precompiles
          common.BytesToAddress([]byte{4}):
            {Balance: big.NewInt(1)}, // Identity    precompiles
          common.BytesToAddress([]byte{5}):
            {Balance: big.NewInt(1)}, // ModExp      precompiles
          common.BytesToAddress([]byte{6}):
            {Balance: big.NewInt(1)}, // ECAdd       precompiles
          common.BytesToAddress([]byte{7}):
            {Balance: big.NewInt(1)}, // ECScalarMul precompiles
          common.BytesToAddress([]byte{8}):
            {Balance: big.NewInt(1)}, // ECPairing   precompiles
          faucetAddr:
            {Balance: new(big.Int)
                      .Sub(new(big.Int)
                      .Lsh(big.NewInt(1), 256) ,
                      big.NewInt(9))
            },
       }
  alloc := core.GenesisAlloc(addr)
  backend := backends.NewSimulatedBackend(
          alloc, 9000000 /* gas limit */)

  observations: All precompiles need to own some ether to remove
                purging-account differences among nodes.

  BalanceAt/BlockByNumber/deploy+interact with contracts work as
  ussual with ethclient.Client.

### Overwrite SendTransaction to behave like ethclient.SendTransaction [[{]]
  simulated blockchain allows for interesting scenarios:
  - By skipping Commit() after every transaction, TX-per-block
    can be tunned.
  - Rollback() can abort all pending (not commited) transaction
    (simulate TXs dropped from TX pool).                              [[}]]
[[}]]
[[dev_framework.go}]]


