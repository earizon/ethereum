# Truffle Framework [[{dev_framework.js.truffle,12_solidity,13_SLC.testing,02_QA,13_SLC.debugging]]
  - Truffle Framework Full Journey: <https://www.truffleframework.com/>
  - Truffle Framework Code reference:
    - https://github.com/trufflesuite/truffle/tree/develop/packages
    - https://github.com/trufflesuite/truffle/tree/next/packages/contract-tests/test
      ├─ errors.js: Error control example for "Out of gas", "revert reason". [[{02_QA.error_control}]]
      ├─ events.js: Example tests showing how to test for expected  future/past events [[{13_SLC.testing,10_EVM.events}]]
      ├─ abiV2.js
      ├─ cloning.js
      ├─ customoptions.js
      ├─ deploy.js: Example code showing deploy timeout control    [[{10_EVM.gas]]
      │             pre-flight gas-cost-estimation
      │             .on("confirmation",...) block-depth confirmation number  [[}]]
      ├─ deprecated_keys.js
      ├─ linking.js: Examples linking lib-to-lib, selective-relink, lib-to-SC,
      │             triggering compilations from JS code,
      ├─ methods.js
      ├─ networkObject.js
      ├─ networks.js
      ├─ separation.js
      └─ util.js


$ mkdir fibonacci                          ● CREATE NEW BARE TRUFFLE PROJECT
$ cd fibonacci
$ truffle init
 (Next files will be created)
 + ./contracts/Migrations.sol              <- WARN: DON'T TOUCH THIS FILE
 + ./migrations/1_initial_migration.js     <- WARN: DON'T TOUCH THIS FILE
 + test/
 + build/contracts/                        <- WARN: build/contracts/ MUST BE VERSIONED IN GIT.
                                              - Important compilation metadata is recorded here as JSON.
                                              - On successful deployments ("migrations") the JSON is
                                                updated (.network[$chainId]). Ej:
                                                $ cat build/contracts/ERC20.json | jq ".networks"
                                                {
                                                  "1": {                          <- ChainID (1 == "MainNet")
                                                    "events": {},                 <- Events emitted
                                                    "links": {                    <- Info to any library linked during
                                                      "somelinkedlib": "0x3c5..."    deployment
                                                    },
                                                    "address": "0x77f90...",      <- Deployed SC address. Needed by clients.
                                                    "transactionhash": "0x603..." <- Can be used to find block number
                                                  }
                                                  "111": { ...  }                 <- Some testnet.
                                                }

 + truffle-config.js                       <- Config remote Nodes and wallets used for
     ...                                      testing and deployment. By default the test network
     networks: {                              localhost:8545 is configured using existing wallets
       development: {                         managed by node (probably ganache)
         host: "127.0.0.1",
         port: 8545,
         network_id: "*"
       }
     }
$ editor contracts/Fibonacci.sol                       Create alphabetically ORDERED deployment script
$ editor migrations/2_deploy_contracts.js           <- to deploy the new S.C.
  const LibA = artifacts.require('LibA')      ┌······· require: similar to node.js "require" but it reads
  const B    = artifacts.require("Fibona..")  ·        *.json ABI (generated at compile time) as input and
                         └──────┴─············┘        returns autogenerated JS proxy code in charge of

UPDATE: 2022-07-25: artifacts.require is meant to be used in tests ONLY.
        Use "truffle-contract" in production code like:
        const contractBuilder = require("truffle-contract");
        const JSON = require("ABI/MyContract.json");
        const MyContract = contractBuilder(JSON);
        const deployedInstance = MyContract.deployed()
        ...

  module.exports = function(      deployer, network, accounts injected by truffle at migrate-time
        deployer,                 <- REF: https://github.com/trufflesuite
                                            /truffle-deployer/blob/develop/index.js
                                     Object with info about network, web3 (wallet) provider,
                                     basePath (== options.basePath || process.cwd())
        network,                  <- injected by truffle at migrate-time
        accounts                  <- ("wallets") defined in truffle-config.js
  ) {                                or retrieved from node
    if (network == "test") {
       deployer.deploy(LibA);     ← Deploy runs synchronously. Code waits until transaction has been mined
                                    in blockchain.
       deployer.link(library, A)  ← ☞ Link must be done before deployment
                                    (Ignored if contract doesn't rely on the library)
                                    <https://github.com/trufflesuite/truffle/tree/master/packages/contract>
       deployer.deploy(A)         ← Set "A".address after correct deployment
       deployer.deploy(B,           overriding any previous one.
              A.address,          ← First constructor argument of B (A instance)
              { overwrite: true } ← Other options: gas, from
          );
       );
    } else if (network == "prod") {
       // Fetch A address from "somewhere"
       deployer.deploy(
           B, A.address,
            { overwrite: false } );
    }
  };

$ truffle compile                         <- Generates build/contracts/*.json, to be
                                             used by JS code to genetare JS "proxy" objects.
$ truffle migrate                         <- Migrate (deploy) to default net. in truffle-config.js
$ editor test/TestFibonacci.js            <- test S.C. behaviour as seen by external JS clients
                                             (front-end Dapps). Sort of "functional" tests.
                                             test js code ussually deploy new S.C. isolated from
                                             real ones, but any test is free to reuse already
                                             deployed contracts, libraries, ...
                                             The deployment JS code will mostly similar to the code
                                             used in migrations/*js

$ truffle test                            <- Execute tests.
$ truffle deploy                          <- Deploy contract. It will deploy Migrations.sol
                                             (if not yet done) to keep trace of deployments.
## TRUFFLE: DEBUG MINED TX
  NOTE: Trufle 5.1 introduces also debugging from JS tests:
  PRESETUP) node defined in truffle-config.js up-and-running
  $ truffle console
  truffle(dev)> compile --all             <- Optional. Recompile all if needed.

  truffle(dev)> migrate                   <- In case of error, check also node logs for related info
  > ...                                      (TX hash can help to match errors in truffle console with
  > migration: 1_initial_migration.js        node logs)
  > ...
  > migration: 2_deploy_contracts.js
  > ...
  truffle(dev)> Fibonacci.deployed()
       .then(instance =>                  <- instance is a JS "proxy" to a deployed contract.
          instance.generateFib(10))       <- automatically generates signed TX + JSON/RPC remote call
  > { tx: '0xf47f...41c',
  >   receipt:
  >    { transactionHash: '0x1234....',   <- Use it to identify MINED transaction.
  >      blockHash: ...,
  >      logs: [...],
  >      status: '0x01',
  >      gasUsed: 298373,
  >      ...
  >    },
  >   logs: [...]                         <- logs == "emitted events"
  > }

  truffle(dev)> debug   0x1234...         <- 0x1234... == receipt.transactionHash
  > Gathering transaction data...
  > Addresses affected:
  >  0x33b217190... - Fibonacci
  > ...
  > Fibonacci.sol:                     ┌─ Debugger Commands───────────────────────────────────┐
  > ...                                │ v) print vars:val  b)TOGGLE      BREAKPOINT          │
  > 3: contract Fibonacci              │ n) step next       c)CONTINUE to BREAKPOINT          │
  >    ^^^^^^^^^^^^^^^^^^              │ o) step over       +:<expr>) ADD  WATCH EXPRESSION   │
  debug(dev:0xf4...)> n                │ i) step into       -:<expr>) DEL  WATCH EXPRESSION   │
  > 8:   function generateFib ...      │ u) step out        :<expr> ) EVAL       EXPRESSION   │
  >      ^^^^^^^^^^^^^^^^^^^^^^^^^^    │                    ?       ) LIST WATCH EXPRESSION/S │
  >                                    │                                                      │
  (Move until reaching the for-loop)   │ ;)step  instruct.                          h) help   │
  debug(dev:0xf4...)>  v               │ p)print instruct.                          q) quit   │
  >         i: 0                       └──────────────────────────────────────────────────────┘
  >         n: 10
  > fibseries: []
  debug(dev:0xf4...)>  +:{ i, fibseries } <- new watch expression shown after instruction
  debug(dev:0xf4...)> n
  > ...
  > ...
  > fibseries: [1, 1, 2, 3, ..., 55]

## TRUFFLE RECIPES:
  $ truffle compile --all     <- force recompile all of the contracts.
  $ migrate --reset           <- Reset existing migrations/migration state.


## Truffle Migrations Explained: [[{devops.smart_contract.migration]]
  (Summary from Bernard Peh post: https://medium.com/@blockchain101/demystifying-truffle-migrate-21afbcdf3264)

  - Migrations.sol instance is used to "bookmark" LAST SUCCESFUL MIGRATION:
    ...
    contract Migrations {                     ┌·· On truffle console value can be check like:
      uint public last_completed_migration; <·┘   | Migrations.deployed().then( sc =>
      ...                                         |   sc.last_completed_migration.call()
                                                  |   .then(v => console.log(v) ) )
      function setCompleted(uint completed) <···· Invoqued whenever a migration/*.js script
      public {                                    is completed successfully.
        last_completed_migration = completed;
      }
      ... (upgrade ) ...
    }

  1ST MIGRATION EXECUTION                            2ND UPGRADED METACOIN MIGRATION
  migration SETUP:                                   migration SETUP:
  └./migrations/1_initial_migration.js               └./migrations/1_initial_migration.js
  └./migrations/2_deploy_contracts.js                └./migrations/2_deploy_contracts.js
                └───────┬────────┘                   └./migrations/3_deploy_upgraded_metacoin.js
                ┌───────┘                                          └───────────┬───────────────┘
                │                                        ┌─────────────────────┘
                ...                                      ...
                deployer.deploy(ConvertLib);             // deployer.deploy(ConvertLib); ← Commented (Save gas)
                deployer.link(ConvertLib, MetaCoin);     deployer.link(ConvertLib, MetaCoin);
                deployer.deploy(MetaCoin);               deployer.deploy(MetaCoin);


  (or --reset flag added)
  $ truffle migrate                               $ truffle migrate
  > Compiling ...                                 > ...
  > ...                                           > last_completed_migration == 2 → start at migrations/3_*.js
  > Running migration:  1_initial_migration.js    > (☞Migration and ConvertLib skipped)
  >   Deploying Migrations...                     > Running migration:  3_deploy_upgraded_metacoin.js
  >   ... 0x68fe0...   (deploy TXhash)            > Replacing MetaCoin...
  >   Migrations: 0x213....(Contract address)     > ... 0xe9d0481...      (deploy TX hash )
  > Saving successful migration to network...     > MetaCoin: 0xf55...    (Contract address)
  >   ... 0xe2807...   (setCompleted() TXhash)    > Saving successful migration to network...
  > Saving artifacts...                           > ... 0xcf8f9...         (setCompleted TX hash)
  > Running migration:  2_deploy_contracts.js     > Saving artifacts...
  >   Deploying ConvertLib...
  >   ... 0xce792...       (deploy TXhash )
  >   ConvertLib: 0x13e... (Contract address)
  >   Linking ConvertLib to MetaCoin
  >   Deploying MetaCoin...
  >   ... 0x2fcab...       (deploy TXhash )
  >   MetaCoin: 0x0d9...   (Contract address)
  > Saving successful migration to network...
  >   ... 0xe2807...       (setCompleted() TXhash)
  > Saving artifacts...
[[}]]


## Truffle Framework: Security: [[{security,02_QA,01_PM.TODO.NOW]]
<https://github.com/ConsenSys/truffle-security>
  - MythX Security Analysis Plugin for Truffle Framework
  - adds automated smart contract security analysis to the
    Truffle framework.
  - Compatible with Truffle 4.0 or higher.
[[}]]

## Truffle Framework: IPFS/Filecoin: [[{scalability.offchain,infrastructure.storage.offchain,01_PM.TODO]]
<https://www.trufflesuite.com/blog/announcing-collaboration-with-filecoin>
[[}]]


## Truffle Framework: migrating to web3 v1.0 [[{01_PM.TODO]]
<https://medium.com/@adrianmcli/migrating-your-truffle-project-to-web3-v1-0-ed3a56f11a4>
 "... Unfortunately Truffle uses the 0.20.x version of Web3.js
      instead of vs v1.0+, providing a more easier to work with API (e.g.:
       PromiEvents
[[}]]

# Non Classified notes: [[{]]
## Ethers.js is compatible with Truffle according to:
  https://ethereum.stackexchange.com/questions/50632/can-i-use-ether-js-with-truffle
  """ ...
     Truffle use Web3 by default and its injected inside as (hardcoded) global dependency.
     You CAN install ether.js as dependency:
       $ truffle init
       $ npm install --save ethers

     and then use it in truffle tests:
       var ethers = require('ethers');

     It is NOT compatible with "truffle develop" since only web3 would be injected.
  """
[[}]]


[[dev_framework.js.truffle}]]


