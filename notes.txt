## Apropos
* Visit next URL to display the document:
  [this URL](https://earizon.github.io/txt_world_domination/viewer.html?payload=../ethereum/notes.md)
  (proper standard markup support is WiP)

* If you want to contribute to great gistory of this document you can take the next flight to:
@[https://www.github.com/earizon/ethereum]
  Your commits and pull-request will be immortalized
  in the Pantheon of the Unicode Gods.

## topics Acronyms

- PM  : Project Management
- SLC : software life cycle
- QA  : Quality Assurance. Everything realated to removing errors,
        passing unit/functional/acceptance tests, Service Level Agreements (SLAs), ...
- 101 : (pronounced ONE-oh-ONE). Slang term for the most basic knowledge in
        some subject. @[https://en.wikipedia.org/wiki/1(slang)]
- EVM : Ethereum Virtual Machine.

## External Links

- @[https://github.com/ethereum/wiki/wiki/White-Paper]
- @[https://ethereum.github.io/yellowpaper/paper.pdf]
- @[https://solidity.readthedocs.io/]
- @[https://solidity.readthedocs.io/en/latest/resources.html] Solidity Resources
- @[https://github.com/ethereum/wiki/wiki/JSON-RPC]
- @[https://github.com/ethereum/wiki/wiki/Design-Rationale]
- @[https://theethereum.wiki/w/index.php/Main_Page]
- @[https://ethereum-magicians.org]

- Solidity top questions@ethereum.stackexchange.com
@[https://ethereum.stackexchange.com/questions/tagged/solidity?sort=votes&pageSize=15]
- Enterprise Ethereum Alliance Resources:
@[https://entethalliance.org/resources/]
- Curated list of libraries, auditing/secuirity tools, dev tools, security tutorial links,...
@[https://github.com/bkrem/awesome-solidity]
- Multipurspose Eth. Ontology:
@[https://media.consensys.net/ethon-introducing-semantic-ethereum-15f1f0696986]
 @[https://github.com/ConsenSys/EthOn/]
 @[https://ethon.consensys.net/statistics.html]
- EVM:
@[https://github.com/pirapira/awesome-ethereum-virtual-machine]
@[https://github.com/ethereum/go-ethereum/tree/master/core/vm]
@[https://github.com/xf00f/web3x/tree/master/web3x-evm] TypeScript implementation

- Lot of interesting repos related to Ethereum:
@[https://github.com/pirapira?utf8=%E2%9C%93&tab=repositories&q=&type=source]

## Related Taxonomies: [[{standards,PM.ext_resource,doc_has.taxonomy,PM.WiP]]

- TokenTaxonomyFramework
  @[https://github.com/InterWorkAlliance/TokenTaxonomyFramework]
  @[https://interwork.org/real-world-tokens-a-seven-step-journey-into-the-ttf/]
- Laws/Legal Taxonomy: @[https://law.stackexchange.com/tags]
- Economics  Taxonomy: @[https://economics.stackexchange.com/tags]
[[}]]


[[{101.networks,scalability.evm,scalability.consensus.ethereum2,scalability.layer2,layer2.rollup.optimistic,layer2.rollup.zk]]
## Network Versions, Protocols and Code Updates

@[https://ethereum.github.io/yellowpaper/paper.pdf]
@[https://en.wikipedia.org/wiki/Ethereum#Milestones]

  ```
  Name/Code Name     1st Block  Release     Public Ethereum    Network        Notes
                        Number  date        Network Version    Block Reward
  Frontier                   0  2015-07-30
  ─────────────────────────────────────────────────────────────────────────────────
  Ice Age               200000  2015-09-08
  ─────────────────────────────────────────────────────────────────────────────────
  Homestead            1150000  2016-03-15  Homestead          5 ether
  ─────────────────────────────────────────────────────────────────────────────────
  DAO Fork             1920000  2016-07-20
  ─────────────────────────────────────────────────────────────────────────────────
  Tangerine Whistle    2463000  2016-10-18
  ─────────────────────────────────────────────────────────────────────────────────
  SpuriousDragon       2675000  2016-11-23
  ─────────────────────────────────────────────────────────────────────────────────
  Byzantium            4370000  2017-10-16  Metropolis Part1^1
  ─────────────────────────────────────────────────────────────────────────────────
  Constantinople ^4    7280000  2019-02-28  Metropolis Part2^2
  +                                        ────────────────────────────────────────
  Petersburg           7280000  2019-02-28
  ─────────────────────────────────────────────────────────────────────────────────
  Istanbul             9069000  2019-12-08
  ─────────────────────────────────────────────────────────────────────────────────
  MuirGlacier          9200000  2020-01-02
  ─────────────────────────────────────────────────────────────────────────────────
  Berlin              12244000  2021-04-15
  ─────────────────────────────────────────────────────────────────────────────────
  London              12965000  2021-08-05
  ─────────────────────────────────────────────────────────────────────────────────
  ArrowGlacier        13773000
  ─────────────────────────────────────────────────────────────────────────────────
                                2022-09-XX  Serenity ^3
                                            PoS replacing PoW
                                            "Merge"
  ─────────────────────────────────────────────────────────────────────────────────
                                2023-04-13  Shanghai/Capella   1st simultaneous upgrade of execution and consensus layers.
                                                               Activation of partial&full withdrawals for PoS stakers,
                                                               "likely to encourage increased participation by validators
                                                               and further decentralization by augmenting liquidity"
                                                                About 1hour after Shanghai upgrade activation, some 285
                                                               withdrawals in epoch 194,408 had been processed, for about
                                                               5,413 ETH (~10M$ worth).
* ^1 Byzantium hardfork == """ Ethereum for the masses """.
   @[https://www.infoq.com/news/2017/08/Ethereum-HardFork]
    - It  increases anonymity through Zero-knowledge zk-snark proofs ,
    - It includes more predictable gas charges which were becoming
      difficult to calculate with the increased number of ICOs.
* ^2 Metropolis Part 2,Constantinople: (Aka "Ethereum 2.0"):
     - It lays the fundations of PoS(Casper consensus): According to
 @[https://www.trustnodes.com/2019/06/15/ethereum-2-0-planned-for-launch-on-the-3rd-of-january-2020]
     ...Phase zero of ethereum 2.0, which enables Proof of Stake (PoS),
        is targeted to launch on the 2020-01-03 .
          Delayed, not yet complete on 2021-12  or 1y9months later.
      - spec freeze: 20??-06-30
        New realistic targets, there are two milestones.
     - First, the deposit contract is to launch ahead
       of the genesis block to allow validators to make deposits.
       .. They’re hoping at least 2 million eth will be deposited
     - Second milestone is the genesis block launch on the day.
       "...This would allow three months of deposits to accumulate
       and 7 months from today for at least two clients to reach
       production status, Drake said.."
       └───────┬───────┘
       production status == """there has been a long running cross
                               client testnet that has gone through
                               security audit, fuzzing, parts have
                               gone through formal verification, and
                               hasn’t suffered major issues for a
                               healthy amount of time."""

* ^3 Serenity: Ethereum 2.0 "last phase", switch to proof of stake
     - huge upgrades on the scalability side (sards, ...)
     - Ethereum 2.0 phases
       - REF: @[https://medium.com/alethio/ethereum-2-0-terms-demystified-8398357429d7]
              2019-08-13
       - Phase 0 — The beacon chain
         - managing validators and stakes
         - organizing and electing committees and proposers
         - applying consensus rules
         - rewarding and penalizing/slashing
       - Phase 1 — Shards
         - constructing the shard chains and blocks
         - anchoring (cross-linking) shard blocks to beacon chain
         - ability to do bETH transfers between validators (this might come
           sooner as it’s not technically linked to work on sharding)
       - Phase 2 — Execution Environments
         - Ewasm based virtual machine for execution of Smart Contracts.
         - every shard has access to all execution environments.
         - ability to make transactions within execution environments.
         - ability to run and interact with smart contracts.
         - cross-shard communication.
     Due to the advances in (optimistic/zk)+Rollups chains it's quite
     possible that Ethereum 2 ends up being Ethereum 1.5
     (Ethereum 1 + Sharding) + zk-Rollups as explained by Vitalik in:
   @[https://ethereum-magicians.org/t/a-rollup-centric-ethereum-roadmap/4698]
     """
      ...base-layer scaling would primarily be focused on scaling how much
      data blocks can hold, and not efficiency of on-chain computation or
      IO operations. The only determinant of the scalability of a rollup is
      how much data the chain can hold, and any increase beyond the current
      ~60 kB/sec will help...
      • Ethereum 1-L1                : ~15 TPS.
      • everyone moving to rollups   : ~3000 TPS.
      • rollups + eth2 sharded-chains:  up to ~100_000 TPS.
      • eth2 + phase2                : ~1000-5000 TPS on L1
                                        (100x less than Rollups).
                                        ^^^^^^^^^^^^^^^^^^^^^^^^.
        IT SEEMS VERY PLAUSIBLE TO ME THAT WHEN PHASE 2 FINALLY COMES,
        ESSENTIALLY NO ONE WILL CARE ABOUT IT.
     """
* ^4 Original Constantinople network upgrade was postponed and two
     protocol upgrades will need to occur on the same block number in
     order to fix issues on various Ethereum test networks (Ropsten,...)
  ```
* REFs:  
  - 2018-06-16: Casper and sharding merger confirmed.
  @[https://www.trustnodes.com/2018/06/16/casper-sharding-merger-confirmed-constantinople-back-table]  
  - 2019-02-22: scheduled upgrade at block number 7,280,000,  predicted on 2019-02-28
  @[https://blog.ethereum.org/2019/02/22/ethereum-constantinople-st-petersburg-upgrade-announcement/]

[[{101.public_chains]]
## Public Chains Comparative
- REFs:
  · @[https://chainid.network/]
  · @[https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md#list-of-chain-ids]
  ·(+ Summary from original project sources)

- NOTE:read Layer2 Rollups section for difference among side-chains and rollups.
       "TLDR" summary:
       - rollups: safest approach, including ZKP advanced cryptography protection.
       - side-chains: simpler/more centrilized/less robuts.
                      Sort of "zipping" many offchain TXs into a single onchain TX.

  ```
                             ┌─ TheGraph Protocol Support
                             · ┌─ 0x Protocol Support
                             · ·
  Chain Name/Chain ID  │Symb│││││││ notes
  ─────────────────────│────│─│─│─│─────────────────────────────────────────────────────
  ethereum             |    | | | |
  └ mainnet/1          | ETH| |y| |
  └ testnet görli/5    | GOR| |y| | https://goerli.net/,  https://gitter.im/goerli/testnet
    (Goerli)           |    | | | | Consensus: Proof-of-Stake (previously Proof-of-Authority!):
                       |    | | | | Faucets" to request test ethers:
                       |    | | | |  https://faucets.chain.link      OK <- 0.1 Eth/day
                       |    | | | |  https://goerli-faucet.pk910.de/ OK <- PoW mint in browser!!
                       |    | | | |  https://t.me/gethfaucet         doesn't loot to work
                       |    | | | |  (https://faucet.goerli.mudit.blog/)
                       |    | | | |  https://goerlifaucet.com/
                       |    | | | |
                       |    | | | | Goerli testnet will be merged with the Prater
                       |    | | | | proof-of-stake beacon chain. This will mark
                       |    | | | | the end of the permissioned PoA phase and
                       |    | | | | everyone will be able to run a validator
                       |    | | | | for Goerli.
                       |    | | | | Officially becoming proof-of-stake (PoS) as of
                       |    | | | | 1:45 am UTC, Aug. 11.
                       |    | | | |
  └ testnet Sepolia/   | ???| |?|?| https://sepolia.dev
      /11155111        |    | | | | Consensus: Proof of Stake !!!
                       |    | | | | RPC Endpoint: https://rpc.sepolia.dev
                       |    | | | |
                       |    | | | | Network/Chain ID: 11155111
                       |    | | | | Genesis Hash: 0x25a5cc106..8993e6dd9
                       |    | | | | Consensus Engine: Proof of Stake
                       |    | | | | EVM Version: London
                       |    | | | |
                       |    | | | | Over long-term, Ethereum team plans on ONLY 
                       |    | | | | MAINTAINING the Goerli and Sepolia testnet, 
                       |    | | | | CLOSED, PERMISSIONED testnet (vs public Goerli),
                       |    | | | | with validators passing capability tests before
                       |    | | | | being allowed access to the network.
 ----------------------+----+-+-+-+---------------------------------------------------------
  └ testnet rinkeby/4  | RIN| | | | Deprecated/Shut down by Q2/Q3 2023.
                       |    | | | |*WARN:*
                       |    | | | | Users and developers are encouraged to migrate ASAP
                       |    | | | | to Goerli or to test Ethereum (Sepolia?) in a post-merge
                       |    | | | | context. !!!
                       |    | | | | After The Merge, Rinkeby will not be a suitable testing
                       |    | | | | environment for the Ethereum mainnet. Unplanned mainnet
                       |    | | | | upgrades may no longer be applied to deprecated testnets.
 ----------------------+----+-+-+-+---------------------------------------------------------
  polygon Main./137    MATIC|Y|Y|Y| type: L2 zk-rollup (previously known as MATIC Network)
  └ Test.Mumbai/80001  MATIC| |Y| | https://polygon.technology/
                       |    | | | | gas-price real-time: https://polygonscan.com/gastracker
                       |    | | | | NOTE:
                       |    | | | | Instead of providing just one or two scaling solutions, Polygon is creating
                       |    | | | | an ecosystem that connects multiple different scaling solutions, including
                       |    | | | | sidechains with different consensus mechanisms and layer-2 options such as
                       |    | | | | Plasma, Optimistic Rollups, and ZK-Rollups.
                       |    | | | | It also includes an optional shared security model.
  ---------------------|----|-|-|-|-----------------------------------------------------
  expanse net/2        | EXP| | | |
  ---------------------|----|-|-|-|-----------------------------------------------------
  thaichain/7          | TCH| | | | thaishield audits verify your
  └ 2.0 thaifi/17      | TFI| | | | distributed systems work as intended.
                       |    | | | | our engineers fully review system’s
                       |    | | | | architecture and codebase, and then
                       |    | | | | write a thorough report with
                       |    | | | | actionable feedback for every issue.
  --------------------------|-|-|-|-----------------------------------------------------
  ubiq/8               | UBQ| | | | built upon improved version of e.codebase,
  └ testnet/9          |    | | | | it offers enterprise-stable pow.
                       |    | | | | conservative upgrade schedule.
  --------------------------|-|-|-|-----------------------------------------------------
  arbitrum one/42161   |AETH|Y| |Y| optimistic rollup.
  └ test.rinkeby/421611|aRETH | | | integrated with binance exchange
                       |    | | | | (but withdrawals not yet enabled
                       |    | | | |  as of 2021-11-26  )
  └ on xdai/200        |XDAI| | | |  (research project)
  --------------------------|-|-|-|-----------------------------------------------------
  BNB Smart Chain      |    | | |Y|
                       |    | | | |
                       |    | | | |
  --------------------------|-|-|-|-----------------------------------------------------
  Optimistic Eth./10   |OETH|Y|Y|Y| type: l2 optimistic-rollup
  └ testnet kova/69    | KOR| | | | millisec tx,10-100x cheaper.
  └ testnet goerly/420 | GOR| | | | periodically submit l2 tx merkle root to
                       |    | | | | mainnet, storing N L2 tx 1 tx mainnet.
                       |    | | | | https://chainid.lin/?network=optimism
                       |    | | | | node: https://mainnet.optimism.io
                       |    | | | | expl: https://optimistic.etherscan.io
                       |    | | | | supported by infura.
  --------------------------|-|-|-|-----------------------------------------------------
  Fantom/??            |??? |?|Y|Y|
  └ ???                |    | | | |
  ---------------------|----|-|-|-|-----------------------------------------------------
  xDAI Chain/100       |xDAI|Y| | |  Aims at creating Stable Payments Fees tied to USD
  ---------------------|----|-|-|-|-----------------------------------------------------
  NEAR/???             |????|Y| | | It runs in concert with Ether/Polka./Cosmos/
                       |    | | | |
  ---------------------|----|-|-|-|-----------------------------------------------------
  CELO/???             |????|Y|Y| |• https://celo.org
                       |    | | | |• PoS, mobile-1st platform for fin.dApps+crypto payments
                       |    | | | |• KickStart anounced that its platform will change to
                       |    | | | |  be based on the Celo blockchain in 2021-12.
                       |    | | | |• CELO founders/inverstors include Jack Dorsey (Twitter
                       |    | | | |  CEO), SocialCapital, CoinBase, Telekom, ...
  ---------------------|----|-|-|-|-----------------------------------------------------
  AVALANCHE/???        |????|Y|Y|Y|
  ---------------------|----|-|-|-|-----------------------------------------------------
  StarkNet             |????|?| | |• L2 stark rollup.
                       |    | | | |• Used by SORASE (Paris based company providing
                       |    | | | |  NFTs for "LaLiga", "Gerad Piqué", ...)
                       |    | | | |• Alpha state as of 2022-02-22
  ---------------------|----|-|-|-|-----------------------------------------------------
  POA/???              |????|Y| | |
  ---------------------|----|-|-|-|-----------------------------------------------------
  MOONRIVER/???        |????|Y| | |
  ---------------------|----|-|-|-|-----------------------------------------------------
  Fuse Mainnet/122     |FUSE|Y| | |  "Open Source" Economy, create Branded wallets...
  └ Sparknet/123       SPARK| | | |  47 validators, ...
  ---------------------|----|-|-|-|-----------------------------------------------------
  palm Main./^1        |PALM| | |Y| sidechain for selling&trading
  └ Testnet/^2         |PALM| | | | real-world and digi. assets NFTs.
  ^1:11297108109       |    | | | | IBFT 2.0 poa consensus.
  ^2:11297108099       |    | | | | (pseudo-centralized/consortium net).
                       |    | | | | automated mainnet bridge relay service.
                       |    | | | | Connect payment tokens (DAI, NFTs) with
                       |    | | | | bridging contracts deployed on both
                       |    | | | | networks. Fees collected from this
                       |    | | | | bridge are partially used to purchase
                       |    | | | | carbon offsets.
                       |    | | | | -
  ---------------------+----|-|-|-|-----------------------------------------------------
  Metadium Main./11    |META| | | | Self Sov. Identity with 2 Factor Authentication
  └ Testnet/12         | KAL| | | |
  ---------------------|----|-|-|-|-----------------------------------------------------
  GoodData Main./32    |GooD| | | |  NFTs/"Metaverse"
  └ Testnet/33         |GooD| | | |  AI and ML Optimize Rewards
                       |    | | | |  Region-aware distributed storage
  ---------------------|----|-|-|-|-----------------------------------------------------
  Telos EVM Main./40   |TLOS| | | |  "The most scalable E.platform available today"
  └ Testnet/41         |TLOS| | | |  Fixed gas fee. Enviro.Friendly
                       |    | | | |  ESG compliance
  ---------------------|----|-|-|-|-----------------------------------------------------
  CoinEx SmartCh./52   | CET| | | |  PoS based. Permission-free, low fess.
  └ Testnet/53         |CETT| | | |  Finance oriented
  ---------------------|----|-|-|-|-----------------------------------------------------
  Ontology Main./58    | ONG| | | |  Focus:Decentralized IDentity. Customers include
  └ Testnet/5851       | ONG| | | |  Daimler Benz Mobility.
                       |    | | | |  App User base: 50% Asia, 7% USA.
                       |    | | | |  partnered with rOCKI, next-gen music [NFT]
                       |    | | | |  streaming service and NFT platform built on
                       |    | | | |  Binance Smart Chain (BSC) to use its DID solution
                       |    | | | |  to prevent badn actors impersonating artists.
                       |    | | | |  Multi-Virtual Machine supports.
                       |    | | | |  "Ont. has its own VM, and also supports Wasm, NeoVM.
                       |    | | | |  and EVM....  Devs can now use Ont.Bridge to convert
                       |    | | | |  Ont.Native OEP4 to ORC20 tokens, adding to MetaMask,
                       |    | | | |  and deploying dApps.
  ---------------------|----|-|-|-|-----------------------------------------------------
  GoChain Main./60     |  GO| | | |  Proof of Reputation (PoR) web3 based public+private
  └ Testnet/31337      |  GO| | | |  1300 TX/sec.(10000x greener, 1000x cheaper)
                       |    | | | |  Run by Lenovo, RMIT university, Nicosia University,
                       |    | | | |  Pennsylvania State University, ...
                       |    | | | |  Quite active as of 2021-11 according to:
                       |    | | | |@[https://medium.com/gochain]
                       |    | | | |  Clientes include Fortune 500 companies,
                       |    | | | |  Compañía Nacional de Minería de Colombia,
                       |    | | | |  Services include:
                       |    | | | |  - Zeromint NFT Marketplace and Chainparency.
  --------------------------|-|-|-|-----------------------------------------------------
  OKExChain Main./65   | OKT| | | |  Decentralized Exchange (DEX) oriented, running
  └ Mainnet/66         | OKT| | | |  "on top" Cosmos + EVM.
  ---------------------|----|-|-|-|-----------------------------------------------------
  POA Network Core/99  | POA| | | |
  └ Sokol/77           | SKL| | | |
  ---------------------|----|-|-|-|-----------------------------------------------------
  PrimusChain          |    | | | |
  └ Main./78           |PETH| | | |
  ---------------------|----|-|-|-|-----------------------------------------------------
  Meter Mainnet/82     | MTR| | | |  "High performance infra" allowing S.C. to
  └ Testnet/83         | MTR| | | |  "travel" through heterogeneous blockchain networks.
                       |    | | | |  Partneting with ChainLink, Harmony, Poligy,
                       |    | | | |  Standard Tokenization Protocol, Oasis Foundation,
                       |    | | | |  ...
                       |    | | | |  100+ validators.
  ---------------------|----|-|-|-|-----------------------------------------------------
  Lightstreams         |    | | | |
  └ Mainnet/162        | PHT| | | |  Built on Tendermint consensus ("Cosmos"). According
  └ Testnet/163        | PHT| | | |  to page: a $5.63 TX in E.MainNet becomes $0.0002 in
                       |    | | | |  lightstreams. $42.30 Uniswap reduces to $0.0016.
                       |    | | | |  x25 faster with install 3secs. settlement.
                       |    | | | |  Doesn't look to be very active. 1/2 post per year.
  ---------------------|----|-|-|-|-----------------------------------------------------
  BitTorrent Ch./199   | BTT| | | |  Blokchain tokenizing BitTorrent Decentralized
  └ Testnet/1028       | BTT| | | |  file sharing protocol.
  ---------------------|----|-|-|-|-----------------------------------------------------
  Freight Trust        |    | | | |  Focus on regulated/compliant SupplyChain.
        Network/211    | 0xF| | | |  EID X12, EDINT AS2/AS4,
                       |    | | | |  EDI EDIFACT, Custom/Imports,
                       |    | | | |  Custom/Exports, Freight Forwarders
  ---------------------|----|-|-|-|-----------------------------------------------------
  Energy Web Ch./246   | ???| | | |  https://energyweb.org/
                       |    | | | |  "World’s first public, enterprise-grade
                       |    | | | |   blockchain tailored to the energy sector"
                       |    | | | |  46 projects in 21 countries
                       |    | | | |  with 41 partners as of 2021-11
                       |    | | | |  W3C DID is used as core Identity building block.
                       |    | | | |  Identity is provided to any customer, asset,
                       |    | | | |  utility or regulator.
  ---------------------|----|-|-|-|-----------------------------------------------------
  Theta                |    | | | |  Specialized in peer-to-peer (real-time)video
  └ Mainet    /361     TFUEL| | | |  streaming/transcoding.
  └ Testnet   /365     TFUEL| | | |  streaming/transcoding.
    Sap.Test. /363     TFUEL| | | |  Compat. with EVM Constantinople plus
    Amber Test/364     TFUEL| | | |  a couple of key Istanbul features.
                       |    | | | |  Global partners including Google, Samsung,
                       |    | | | |  Binance, Blockchain.com, and Gumi.
  ---------------------|----|-|-|-|-----------------------------------------------------
  Acala Network/787    | ACA| | | |  layer-1 with built-in liquidity and
  └ Testnet/595        |mACA| | | |  ready-made fin.apps + trustless
                       |    | | | |  exchange, decentralized stablecoin
                       |    | | | |  (aUSD), DOT Liquid Staking (LDOT),
                       |    | | | |  and EVM+. supported by Polkadot Substrate.
  ---------------------|----|-|-|-|-----------------------------------------------------
  Ambros Chain         |AMBR| | | |  600+ PoA network designed for IoT.
  └ MainNet/ 880       |AMBR| | | |  13.848 Holders.
  └ Testnet/8888       |AMBR| | | |  Digital identities are given to devices,
                       |    | | | |  with all data about their condition and
                       |    | | | |  movement securely bundled and automatically
                       |    | | | |  relayed to your blockchain.
  ---------------------|----|-|-|-|-----------------------------------------------------
  Wanchain/888         | WAN| | | |  https://www.wanchain.org/
  └ Testnet/999        | WAN| | | |  Finance oriented Public|Private-to-Public|Private
  ---------------------|----|-|-|-|-----------------------------------------------------
  Clover Main./1023    | CLV| | | |  part of cross-blockhain (EVM, DOT/KSM+ parachains,
  └ Testnet/1024       | CLV| | | |  Solana) project.
  ---------------------|----|-|-|-|-----------------------------------------------------
  Ecoball Main./???    | ECO| | | |  Finance Oriented. Claims to support 100.000 TX/s
  └ Test.Espuma/???    | ECO| | | |  using VPoS and smart-node selection with close-to-zero
                       |    | | | |  trading fees.
                       |    | | | |  25 validator pools and 245 delegators.
  ---------------------|----|-|-|-|-----------------------------------------------------
  QuarkChain           |    | | | |  flexible, scalable, user-oriented
  └ Mainnet            |    | | | |  blockchain infrastructure by using
    └ Root/100000      | QKC| | | |  blockchain sharding technology.
    └ Shards/^1        | QKC| | | |
  └ Devnet
    └ Root/110000      | QKC| | | |
    └ Shards/^2        | QKC| | | |
  ^1:100001..8         |    | | | |
  ^2:100001..8         |    | | | |
  ---------------------|----|-|-|-|-----------------------------------------------------
  Harmony              |    | | |Y|  2-second TX finality @ 1/1000 price.
  └ Mainnet            |    | | | |  Open platform for assets, collectibles,
    └ Shards/^1        |  ON| | | |E identity and governance.
  └ Testnet            |    | | | |  secure bridges offer cross-chain asset
    └ Shards/^2        |  ON| | | |E transfers with E.MainNet, Binance and
    1666600000..3      |    | | | |  3 other chains.
    1666600000..3      |    | | | |  daVinci NFT marketplace: April 2021.
                       |    | | | |
  ---------------------|----|-|-|-|-----------------------------------------------------
  IoTeX Network        |    | | | |@[https://iotex.io/]
  └ Mainnet/4689       |IOTX| | | |  9K+     DEVICES       200K+   COMMUNITY
  └ Testnet/4690       |IOTX| | | |  14,4M   TRANSACTIONS  39,000+ STAKERS
                       |    | | | |  """IEEE Blockchain& IoT Standards
                       |    | | | |   Working Group Appoints IoTeX Head of
                       |    | | | |   Cryptography as Vice Chair """
                       |    | | | |
  ---------------------|----|-|-|-|-----------------------------------------------------
  Binance SmartCh./56  | BNB|Y|Y| |   PoSA = Proof of Stake + Proof of Authority.
  └ Testnet/97         |tBNB| | | |   WARN: "Spam Chain". Very active @ [on Twitter an press](https://www.techtimes.com/articles/268625/20211128/binance-smart-chain-becomes-most-followed-cryptocurrency-on-twitter.htm)
                                             Completely broken in Real World:
                                           @[https://github.com/binance-chain/bsc/issues/553]
  ```

* OTHERS Networks: @[https://chainid.network/]
  ```
    Diode , Flare , ThunderCore, Callisto, ...
  ---------------------|----|-|-|-|-----------------------------------------------------
  "DEAD" Networks/Projects:
  - MathChain/1139,  https://mathchain.org/en/ (Dead SmartWallet AppChain based on (Polkadot) Substrate)
  ```
[[101.public_chains}]]
[[101.networks}]]

# EVM                                                               [[{EVM,PM.ext_resource]]
## External Refs

* @[https://github.com/ethereum/yellowpaper]
* @[https://github.com/ethereum/wiki/wiki/Ethereum-Development-Tutorial]
* @[http://ethdocs.org/en/latest/contracts-and-transactions/developer-tools.html#the-evm]

[[{101.PATRICIA_TREE,EVM.101,persistence.blockchain,infrastructure.storage,infrastructure.network]]
## Patricia tree
@[https://eth.wiki/en/fundamentals/patricia-tree]

- cryptographically fully deterministic "key/value":
  A Patricia trie: cryptographycally protected (key,value) store with
  O(log(n)) inserts/lookups/deletes.
  Much easier to understand and code than alternatives (red-black tries).
- Ethereum use Merkle Patricia Tries (with roots hashed stored in block-header) for:
  ```
  ✓ root-of-state:  ^1
    · trie-path : keccak256(ethereumAddress)
    · trie-value: rlp(ethereumAccount) ← nonce, balance,root-of-contract-storage, codeHash
                                                        └───────────┬──────────┘
  ✓ root-of-transactions:                                 trie-path : keccak256(position-of-variable)
    · trie-path : rlp(transactionIndex)                   trie-value: rlp-encoding of storage value
    · trie-value: rlp(transaction)?

  ✓ root-of-receipts:
    · trie-path : rlp(transactionIndex)
    · trie-value: rlp(receipt)?
  ^1: EVM state :
    @[https://blog.ethereum.org/2019/12/30/eth1x-files-state-of-stateless-ethereum/]
    - 400 million nodes in the state trie. Of these, about 3,000 (but as
      many as 6,000) need to be added or modified every 15 seconds.
      Staying in sync with the Ethereum blockchain is, effectively,
      constantly building a new version of the state trie over
      and over again.
       ... This multi-step process of state trie database operations is why
      Ethereum implementations are so taxing on disk I/O and memory, and
      why even a “fast sync” can take up to 6 hours to complete, even
      on fast connections. To run a full node in Ethereum, a fast SSD (as
      opposed to a cheap, reliable HDD) is a requirement, because
      processing state changes is extremely demanding on disk read/writes.
  ```

- Recursive Length Prefix (RLP) serialization encoding. Tools exist to convert
  from/to JSON objects, ... [[{PM.TODO.101]]
  used on the execution layer everywhere across the consensus layer except the peer
  discovery protocol.
 @[https://eth.wiki/en/fundamentals/rlp]
- Simple serialize (SSZ): Serialization method used on the Beacon Chain, replacing RLP
  SSZ is designed to be deterministic and also to Merkleize efficiently. SSZ can be
  thought of as having two components:
  - a serialization scheme and
  - a Merkleization scheme designed to work efficiently with the serialized data structure
  [[}]]


## RADIX-TRIE: [[{ $radix-trie ]]
- BASIC BUILDING BLOCK OF PATRICIA TIRE:

  ```
  ┌──────────────────────────────────────────────────┐
  │ PRE─SETUP) CHOOSE AN ORDERED ALPHABET.           │
  │ (Hex digits "nibles" in Ethereum implementation) │
  └──────────────────────────────────────────────────┘

  ┌─ NODE "micro─db" ──────────────────────────────────────┐
  │  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F        ← ORDERED (IMPLICIT)
  │  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·        │ POSITION GIVEN AN
  │  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·        │ INITIAL ORDERED ALPHABET
  │ [p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,value]│
  └─ └──────────────────────┬──────────────────────┘ └─┬─┘─┘
    array containing values (keys are implicits,    "information"
    based on order-of-array = order-of-alphabet)    located-in-order
                                                    @end-of-array

    KEY-POINT: trie must be built/calculated "upside-down":
               leaf nodes first, then its leaf-parent, then leaf-grandparents,
               ... finally the root-node.

    • p0..pF values := NULL|keccak256(rlp(pointed-node))
                            └───┬───┘
      "Merkle part" of the Patricia trie.
      KEY POINTs: It root-hash is publicly known, then anyone can
                  provide a proof that the trie has a given value
                  and nobody can provide a false proof for non
                  existing key-values pairs.
  ```

* To fetch the value of key "dog" in trie
  ```
    STEP 1) dog → (to alphabet) → 646F67 ······························┐
    STEP 2) Walk over trie path:                                       ·
     0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F                                   ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] root-node                  ·
    ┌────────────┘                                                     ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] node[0][6]                 ·
    ┌────────┘                                                         ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] node[0][6][4]              ·
    ┌────────────┘                                                     ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] node[0][6][4][6]           ·
    ┌──────────────────────────────┘                                   ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] node[0][6][4][6][F]        ·
    ┌────────────┘                                                     ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] node[0][6][4][6][F][6]     ·
    ┌──────────────┘                                                   ·
    [?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,value] node[0][6][4][6][F][6][7] ←┘
                                     └─┬─┘
     ?: hash-of-pointed-node         dog value!!!
  ```

**PROBLEM**: radix tries are inefficient:  
  A bytes32 needs 64 chars long or over a kilobyte of extra space
  to store one level per character.  
  Each lookup/delete will take the full 64 steps.  
**SOLUTION**: PATRICIA TRIE TO THE RESCUE.

### PATRICIA TRIE:
- Most nodes in the radix-trie will be "empty" (no value) in
  a 64 chars path. Forcing them to have empty values in every index + "target"
  index is a waste.  
  Patricia Trie node extension add next structures:
- encodedPath: "partial path" shortcut to skip ahead using compact encoding.  
  Then the Patricia Trie node wil be one of :
  ```
  - NULL               node: (represented as "empty string")
  - branch    A        node: [ v0, ...,vF, vt ]
  - extension A 2-item node: [ encodedPath, key ]   ← key: used for next db-lookup
  - leaf      A 2-item node: [ encodedPath, value ] ← a flag in 1st nible of encoded
                                                      path marks node as being a leaf.
  ```

- note: To differentiate among nibble 1 and nibble 01, both stored as "01",
        a partial path is prefixed with a flag for odd-cases.
        (See original post for more info) [[$radix-trie}]]
[[101.PATRICIA_TREE}]]

[[{solidity,EVM.101,doc_has.diagram]]
## EVM Accounts
@[http://www.ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html]
  ```
  Account   ← same address space both for contract and normal accounts
  ┌─────────────────────────┐
  │bytes[32]       address  │
  ├─────────────────────────┤
  │wei             balance  │
  ├─────────────────────────┤
  │Map<256b,256b>  storage  │
  └─────────────────────────┘

           ┌────────────────────────────────────┬───────────────────────────────────────┐
           │   EXTERNALLY OWNED ACCOUNT         │          CONTRACT ACCOUNTS            │
  ┌────────┼────────────────────────────────────┼───────────────────────────────────────┤
  │CREATION│→ Generate random 32bytes priv. key │→Create smart─contract source code  ^1 │
  │        │→ Generate Pub.Key from Priv.Key    │→Generate bytecode by compiling source │
  │        │→ Generate public address as:       │→Send "Contract Creation" TX for mining│
  │        │  bytes[32] pub.addr= hash(pub.addr)│→keep Contract address once "published"│
  │        │                                    │ (determined from nonce)               │
  ├────────┼────────────────────────────────────┼───────────────────────────────────────┤
  │CONTROL │Private Key: Only the (human) owner │ BYTECODE                              │
  │BY      │of the  secret  private key can     │                                       │
  │        │decrease the balance by signing new │                                       │
  │        │TX                                  │                                       │
  ├────────┼────────────────────────────────────┼───────────────────────────────────────┤
  │FEATURES│ bytes[32] address                  │ bytes[32] address ^1                  │
  │        │                                    │ Map<256b,256b> storage ^2             │
  ├────────┼────────────────────────────────────┼───────────────────────────────────────┤
  │ADDRESS │ Generated deterministically from   │ Generated deterministically from      │
  │        │ priv.key (→ pub.key → hash(pub.key)│ priv.key , bytecode,  TX.nonce        │
  └────────┴────────────────────────────────────┴───────────────────────────^───────────┘
                                    ┌───────────────────────────────────────┘
                                    ├─It's recomended to change the nonce when deploying
                                    │ to two or more different networks, since there is
                                    │ a small but finite possibility, that TXs can be
                                    │ replayed on such networks.
                                    └─For private networks contracts can also be deployed
                                      in the genesis.json block assigned to any arbitrary
                                      (easy-to-remember) address.

 ^2: account.storage: Persistent memory area
     - It is not possible to enumerate storage from within a contract
     - It is comparatively costly to read and even more so, to modify storage
       in the context of an (update state) TX. (It's still free of cost during
       external query calls).
     - A contract can neither read nor write to any storage apart from its own

  Signing transactions Flow:
   - Identify the next available nonce for the sender account
   - Create the RawTransaction object
   - Encode the RawTransaction object using Recursive Length Prefix encoding
   - Sign the RawTransaction object
   - Send the RawTransaction object to a node for processing
  ```
* The nonce is an increasing numeric value which is used to uniquely identify
  transactions. A nonce can only be used once and until a transaction is mined,
  it is possible to send multiple versions of a transaction with the same nonce,
  however, once mined, any subsequent submissions will be rejected.
[[}]]

## EVM: State transition function [[{transaction.101,EVM.101,consensus]]

- Basically the state of the EVM evolves in "time" through the
  execution of the state transtion function taking as input
  a signed transaction and the current state and updating the
  internal storage as output result:
  ```
  APPLY (S, TX) → S'  ← S : initial global state
                      ← S': final   global state
  ```
  Notice also that real execution not only writes to storage but 
  also produces new inmutable logs ("events" as seen by external Dapps).

### It can be defined as follows:   

- Signature is valid, and the nonce matches the nonce in the
  sender's account.  Return an error otherwise.
- Calculate the transaction fee as STAR_GAS * GAS_PRICE, and
  determine the sending address from the signature. Subtract the
  fee from the sender's account balance and increment the
  sender's nonce. If sender's balance < fee, return an error.
- Initialize GAS = STARTGAS, and take off a certain quantity
  of gas per byte to pay for the bytes in the transaction.
- Transfer the TX value from the sender's account to the
  receiving account.  If the receiving account does not yet
  exist, create if. If the receiving account is a contract,
  run the contract's code either to completion or until the
  execution runs out of gas.
- If the value transfer failed because the sender did not have
  enough money, or the code execution ran out of gas, revert
  all state changes except the payment of the fees, and add
  the fees to the miner's account
- Otherwise, refund the fees for all remaining gas to
  the sender, and send the fees paid for gas consumed to the
  miner.
[[}]]



[[{EVM.101,QA.error_control,doc_has.diagram]]
## CALL Op. (Message Calls)
  - Contracts can user message calls to call other contracts or send Ether to
    non-contract accounts.

```
        ETHEREUM NETWORK
         o······o······o
         ·      ·      ·   ─ → ─  Gossip Protocol
         o      o─  → ─o
         ·      ↑      ↓
  local→ o─  → ─o······O ← Mining
  node        ↑        │   node
         │           ┌─┘
         │           │
         │           │ Signed TX is mapped to the top─level
   Signed TX         │ message call by Mining Node
         ↑   ┌───────│────────────────────────────────── EVM executing at Mining Node ──┐
  ┌──────┴─┐ │       ↓                     ┌─────┐                               ┌─────┐│
  │external│ │      top─level              │sc01 │                               │sc02 ││
  │client  │ │      message call       ──→ │funcA│  → message call ────────────→ │funcB││
  └────────┘ │                             └─────┘                               └─────┘│
             │      ───────────────          │  ^     ────────────                  │   │
             │      sender  = tx signer addr │  │     sender  = sc01.addr           │   │
             │      target  = sc01.add  ^1   │  │     target  = sc02.addr           │   │
             │      payload = abi(funcA+args)│  │     payload = abi(funcB+arggs)    │   │
             │      value   = 0+gweis        │  │     value   = 0+gweis             │   │
             │      gas     = ^2             │  │     gas     = ^2                  │   │
             │   ^3 return data  ←───────────┘  └──── return data  ←────────────────┘   │
             └──────────────────────────────────────────────────────────────────────────┘

    ^1 : target can also be an external (non-contract) account (or even == "sender")

    ^2 : Enough gas to execute called function, but small enought to avoid
         wasting too-much ethers (because of software bugs, gas-price, ...)
         Contracts decide how much remaining gas is sent within calls to other
         contracts.
         An (out-of-gas|*) exception in inner message call is signalled by an
         error value put onto the stack.
         The gas sent is consumed.
         By default in  Solidity calling contract re-launch a manual exception
         to make exceptions "bubble up" the remote call stack.

    ^3 : return data is stored at  preallocated location  in caller's memory.
         return data of top-level call is not used , since client disconnects as
         soon as local node cofirms Signed TX reception.
         sc01.funcA will use async Events to communicate results.
         (original external client and any other interested cliet will listen for
          such events)
```

   - Calls depth is limited to 1024 (Prefer loops to recursive calls)
[[}]]



## DELEGATECALL Op [[{]]
- v.Homestead+
- mostly indentical to a message call BUT ...
- called code is executed in the context of the calling contract
  ```
  - sender == original msg.sender
  - value  == original msg.value
  - Same storage
  - Same current balance
  - Different Code / Different Program Counter
  - New function stack
  ```
- Used in libraries, since it allows a contract to dynamically load code
  from a different address at runtime.  
  For example to manipulate Complex data structures.  
  Library code is deployed once at a specific address and their code invoqued
  through DELEGATECALL.  
  In comparison to contracts, libraries:
  ```
  - Have no state variables. A reference to struct must be passed.
  - Can NOT inherit nor be inherited
  - Can NOT recieve Ethe
  ```
- Could represent a security risk for calling contract
  which  needs to trust that the receiving contract  while
  manipulating its own storage.
- Replaces   deprecated CALLCODE  fixing bug since CALLCODE did not
  preserve msg.sender and msg.value.
[[}]]

[[{EVM.101,EVM.i/o,EVM.gas]]
## OpCodes Summary
- Ethereum Virtual Machine Opcodes low level reference to EVM:
 @[https://ethervm.io/]
- EVM Illustrated [[{PM.TODO}]]
  @[https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf]

### Opcodes
@[https://github.com/crytic/evm-opcodes]
- EVM is a 256bit machine. It is most natural to manipulate data in chunks of 32 bytes.
- Persistent storage is quite expensive.
- The Solidity compiler makes interesting choices in order to 
  minimize gas usage:

- To interact with a Smart Contract, you send it raw bytes.
- It does some computation, possibly changing its own state,
  and then sends you raw bytes in return.
- Method calling does not actually exist. It is an "illusion"
  created by the ABI (sort of serialization format for RPC calls).
   See notes on "function wrappers" for ABI implementation in
  byte-code generated from Solidity sources.

- We could draw analogies between the architectural tiers of DApp [[{doc_has.comparative]]
  and Web App:
  - A contract is like a web service.   
  - A transaction is like a request.  
  - The blockchain is like the backing database.  
  - ABI is the data-interchange format, like Protocol Buffer.  
  - CORE DIFFERENCE: A backing DDBB always works in a best-effort,
    working as slave of clients. A blockchain "imposes" its consensus
    rules to clients, that acts as slave of the blockchain and must
    be ready to retry transactions at random.
 [[}]]

## EVM Memory

- A contract obtains a freshly cleared instance for each message call.
- Memory is linear and can be addressed at byte level.
-  Reads are limited to a width of 256 bits.
-  Writes can be either 8 bits or 256 bits wide.
- Memory is expanded by a word (256-bit), when accessing
  (either reading or writing) a previously untouched memory word (ie.
  any offset within a word). At the time of expansion, the cost in gas
  must be paid. Memory is more costly the larger it grows (it scales
  quadratically)
- calldata: Separate area of memory whe message call payload is placed
- See also: @[#solidity_storage_magging]

## EVM Stack

- EVM memory area list of 256bits up to 1024 elements used for 
  computations.
- The 16 topmost elements can be moved to the top or swaped wih the 
  top element.
- All other operations take the topmost one (or two, or more) 
  elements and push the result onto the stack.
- top elements can be moved to/from storage/memory, but deeper elements can
  be accessed without first removing elements on top of them.
- (EVM)full computational state: can be defined by the tuple:
  (block_state, transaction, message, code, memory, stack, pc, gas)
  block_state = global state = all accounts (balances + storage)
- selfdestruct(target): Destructor for contract @ address
  - Remaining Ethers are sent to target
  - storage & code are removed from the blockchain state

## EVM SUMMARY
  REF: @[https://github.com/ethereum/go-ethereum/blob/master/core/vm/instructions.go]
  ```
  KEYPOINT: EVM WORKS WITH NEXT INPUTS/OUPUTS:
  1)        BYTECODE: INMUTABLE ARRAY-OF-BYTES WITH OPCODES+OPCODE HARDCODE DATA
  2)Prog.Counter(PC): 32 bytes (0x20 bytes) pointer to next EVM instruction     
  3)Contract Context: To know where contract state is in storage.               
  ··└ Contract State: persistent KEY-VALUE storage                              
  4)EVM "RAM" Memory: INPUT/OUTPUT for Operations WITH RANDOM ACCESS.           
  5)           STACK: INPUT/OUTPUT for Operations WITH FIRST─IN/LAST─OUT ACCESS.
                                                   (Exception: SWAP movements)  
  6)        CALLDATA: INMUTABLE ARRAY OF INPUT DATA (msg.data)                  
  ```

- EVM entrypoint to bytecode is always the ZERO ADDRESS  (vs parametrizable entry point).

- EVM OPCODES: REF: https://www.ethervm.io/
  ```
                    COND.ARIT. END-  DESCRIPTION
                    TIO- ME-  FUNC/
                    NAL  TIC  COMP.
    --------------------------------- BASIC ARITMETHIC
    • ADD/SUB/MUL    |    |    |    | (uint256 values)
      DIV/SDIV       |    |    |    | SDIV == Signed division
      EXP            |    |    |    | EXP a b  == a ** b
      SIGNEXTEND     |    |    |    | SIGNEXTEND b x y ==  y = sign extends x from (b + 1) * 8 bits (up to 256 bits).
    --------------------------------- MODULAR ARITMETHIC
    • MOD/SMOD       |    |    |    | MOD a b = a % b, SMOD == signed mod.
      ADDMOD/MULMOD  |    |    |    | ADMOD  a b N == (a + b) % N
                     |    |    |    | MULMOD a b N == (a * b) % N
    • NOT            |    |    |    |
    --------------------------------- BYTE RELATED OPERATIONS
    • BYTE           |    |    |    | BYTE i x y ==  y = (x >> (248 - i * 8)) &  0xFF
                     |    |    |    | ith byte of (u)int256 x, counting from most significant byte
    • SHL/SHR/SAR    |    |    |    | 256-bit Shift left / right
                     |    |    |    | SAR: int256 (aritmetic) shift right
    • SHA3           |    |    |    | SHA3 offset length  == keccak256(memory[offset:offset+length])
                     |    |    |    | WARN: SHA3 != keccak (Ethereum keccak-256). More info at:
      @[https://ethereum.stackexchange.com/questions/550/which-cryptographic-hash-function-does-ethereum-use]
    --------------------------------- TX ACCOUNT RELATED DATA
    • ADDRESS        |    |    |    | "this". address of executing contract
      BALANCE        |    |    |    | address(addr).balance in wei
      SELFBALANCE    |    |    |    | address(this).balance in wei (v.Istanbul+/EIP-1884)
      ------------------------------- EXTERNAL INPUT FUNCT. INVOCATION
                                      (DATA COMMING FROM "OUTSIDE" THE EVM
      ORIGIN         |    |    |    | ORIGIN tx.origin  ==  transaction origin address
    • CALLER         |    |    |    | == "msg.caller" (EOA or contract) address.
      CALLVALUE      |    |    |    | TX "funds" in wei
      CALLDATALOAD   |    |    |    | CALLDATALOAD i  read (u)int256 msg.data[i:i+32] from message data
      CALLDATASIZE   |    |    |    | message data length in bytes
      CALLDATACOPY   |    |    |    | CALLDATACOPY destOffset offset length. Copy message data like:
                     |    |    |    | memory[destOffset:destOffset+length] = msg.data[offset:offset+length]
      ------------------------------- RETURN VALUE FROM FUNCTION
      RETURNDATASIZE |    |    |    | size-in-bytes of returned data from last external call (v.Byzantium+/EIP-211)
      RETURNDATACOPY |    |    |    | copy returned data (v.Byzantium+/EIP-211)
                     |    |    |    | memory[dst_offset:dst_offset+length) = RETURNDATA[offset:offset+length)
      ------------------------------- Reading Smart Contract Code
    • EXTCODESIZE    |    |    |    | address(addr).code.size for param addr.
      CODESIZE       |    |    |    | address(this).code.size
      EXTCODECOPY    |    |    |    | EXTCODECOPY addr dst offset offset-length. copy contract's bytecode like:
                     |    |    |    | memory[dst_offset:dst_offset+length] = address(addr).code[offset:offset+length]
      CODECOPY       |    |    |    | CODECOPY dst_offset offset-length  copy executing contract's bytecode like:
                     |    |    |    | memory[dst_offset:dst_offset+length) = address(this).code[offset:offset+length)
      ------------------------------- BLOCK RELATED RUNTIME PARAMS.
    • EXTCODEHASH    |    |    |    | EXTCODEHASH addr hash = address(addr).exists ? keccak256(address(addr).code) : 0  (v Constantinople +/ EIP-1052)
      BLOCKHASH      |    |    |    | BLOCKHASH block hash    hash = block.blockHash(block), only valid for 256 most recent blocks excluding current one
      COINBASE       |    |    |    | current block's miner (injected from miner's ethereum config at node startup)
      DIFFICULTY     |    |    |    | current block.difficulty (established by network consensus)
      GAS            |    |    |    | return remaining gas
      GASLIMIT       |    |    |    | current block.gaslimit (established by network consensus)
      GASPRICE       |    |    |    | tx.gasprice established by signer in wei-per-unit-of-gas
      NUMBER         |    |    |    | current block.number
      TIMESTAMP      |    |    |    | current miner block's Unix timestamp in seconds
      CHAINID        |    |    |    | 1: mainnet, 2 Morden testnet(disused),2 Expanse mainnet, 3 Ropsten testnet, 4 Rinkeby testnet
      CHAINID        |    |    |    | 5: Goerli testnet, 42: Kovan testnet (v.Istanbul+/EIP-1344)
      BASEFEE        |    |    |    | v.London+/EIP-3198
      ------------------------------- MEMORY READ/WRITE FROM/TO STACK
    • MLOAD          |    |    |    | MLOAD  offset value  (u)int256 value = memory[offset:offset+32]
      MSTORE         |    |    |    | MSTORE offset value  memory[offset:offset+32] = (uint256) value
      MSTORE8        |    |    |    |                      memory[offset] = value & 0xFF
      MSIZE          |    |    |    | return size-in-bytes of memory for this contract execution.
    --------------------------------- STACK OPERATIONS
    • ISZERO         |    |    |    | Push 1 if topmost value is zero
      DUP1/2/../17   |    |    |    | clone 1st/2nd/3rd/... element in stack with "0th"
      SWAP1..17      |    |    |    | Swap  1st/2nd/3rd/... element in stack with "0th"
      PUSH1/.../33   |    |    |    |PUSH 1/2/3/.../33 byte value onto start
      POP            |    |    |    | pops and discard (u)int256 from stack.
    --------------------------------- CONTRACT STORAGE
    • SLOAD          |    |    |    | SLOAD  key value, (u)int256 value = storage[key] (read from storage)
      SSTORE         |    |    |    | SSTORE key value, storage[key] = value
    • LT/GT/SLT/SGT/ |XXXX|    |    |
      EQ/ISZERO      |    |    |    |
    • AND/OR/XOR     |XXXX|    |    | 256-bit bitwise ops
    --------------------------------- PC CONTROL "JUMP" OPERATIONS.
    • JUMP           |    |    |    | read-and-pop topmost stack-value, then "jumps" Program Counter to read value.
      JUMPI          |XXXX|    |    | jump condition if 2nd value in stack is NOT "0". (Consume 2 stack values)
    • JUMPDEST       |    |    |    | Target location must contain JUMPDEST opcode (otherwise exec.
                     |    |    |    | fails). This checking is the sole purpose of JUMPDEST, mark
                     |    |    |    | location as valid jump target).
    • PC             |    |    |    | Program counter value
    --------------------------------- FUNCTION INVOCATION
      CALLCODE       |    |    |    | gas addr value args_offset args_length ret_offset  ret_length. call method IN this contract?
      CALL           |    |    |    | gas addr value args_offset args_length ret_offset  ret_length. call method IN ANOTHER CONTRACT
      DELEGATECALL   |    |    |    | gas addr       args_offset args_length  ret_offset ret_length. call method IN ANOTHER CONTRACT
                     |    |    |    |                                                                using current storage (v.Homestead+/EIP-7)
      STATICCALL     |    |    |    | gas addr       args_offset args_length  ret_offset ret_length. call method IN ANOTHER CONTRACT
                     |    |    |    |                                                                with state changes disallowed
                     |    |    |    |                                                                (v.Byzantium+/EIP-214)
    • RETURN         |    |    |X   | offset length , Returns data from a portion of the EVM's memory. (return memory[offset:offset+length])
    --------------------------------- TX ABORT
    • REVERT         |    |    |X   | REVERT  offset  length  -   revert(memory[offset:offset+length])    Byzantium hardfork, EIP-140: reverts with return data FE  Invalid     -   -   -   -
    • STOP           |    |    |X   |unconditional halts execution
    --------------------------------- TX ABORT
    • LOG0...4       |    |    |    | Output Log (Indexed event) generation readable by clients
                     |    |    |    | LOG0(memory[offset:offset+length])  fires an event
                     |    |    |    | LOG1(memory[offset:offset+length], topic0)  fires an event
                     |    |    |    | LOG2(memory[offset:offset+length], topic0, topic1)  fires an event
                     |    |    |    | LOG3(memory[offset:offset+length], topic0, topic1, topic2)  fires an event
                     |    |    |    | LOG4(memory[offset:offset+length], topic0, topic1, topic2, topic3)  fires an event(vs OpCodes)
    --------------------------------- CONTRACT LIFE CYCLE
    • SELFDESTRUCT   |    |    |    | SELFDESTRUCT addr, destroy "this" contract, then sends all remaining funds to "addr".
    • CREATE2        |    |    |    | value offset length salt addr.  addr = new memory[offset:offset+length].value(value)
                     |    |    |    | (v.Constantinople+/EIP-1014). Creates child contract with deterministic address
  ```

[[}]]

[[{EVM.abi]]
## ABI Spec

* Full reference at @[https://solidity.readthedocs.io/en/latest/abi-spec.html]

- The encoding is not self describing and thus requires a schema in order to decode.
- Interface functions of a contract are strongly typed
  (known at compilation time and static)
- All contracts will have the interface definitions of any contracts they call a
  vailable at compile-time.
- Data is encoded according to its type

### FUNCTION SELECTOR:

* Defined as:
  ```
   Keccak-256(hash-of-function-signature)[0,1,2,3]
                       ^------+---------^  ^^^^^^^
                              |            first 4 bytes of keccak256
                              |
                     - canonical expression of the
                       basic prototype without data
                       location specifier :=
                       funct.name with the parenthesised
                       list of parameter types split by a
                       single comma (spaces removed).
                     - Return type is  NOT  part of sign.
                       → No overriding by return type allowed.
                       (this help to keep function call
                        resolution context-independent)

  ARGUMENT (and return value) ENCODING:
  - Starting from fifth byte
  
  -  ELEMENTARY TYPES :
    - uint<M> : unsigned                integer type of 8,16,24,...256 bits,
    -  int<M> : two's complement signed integer type of 8,16,24,...256 bits,
    - address : typed uint160 (function selector uses address not uint160)
    - bool    : typed uint8 restricted to values 0, 1.
    -  fixed<M>x<N>: "M / (10    N)" value signed fixed-point decimal number
                     M bits from 8,16,...256
                     N bits from 0,8,...80
    - ufixed<M>x<N>: unsigned variant of fixed<M>x<N>.
    - fixed,   : synonyms for fixed128x18, ufixed128x18 respectively.
      ufixed
    - bytes<M>: binary type of M bytes, 0 < M <= 32.
    - function: an address (20 bytes) followed by a function selector (4 bytes).
                Encoded identical to bytes24.

  -  (fixed-size) array :
    <type>[M]: a fixed-length array of M elements, M >= 0, of the given type.

  -  non-fixed-size types exist :
    - bytes   : dynamic sized byte sequence
    - string  : dynamic sized unicode string assumed to be UTF-8 encoded
    - <type>[]: a variable-length array of elements of the given type

  -  tuple:  (or tuples of tuples, arrays of tuples,...)
    - (T1,T2,...,Tn): tuple consisting of the types T1, …, Tn, n >= 0
  ```

### Mapping Solidity to ABI types
  ```
  Solidity     ABI Type
  contract     address
  enum         smallest uint type large enough to hold all values
  struct       tuple
  ```

- Formal Specification of the Encoding.  We distinguish two types:
  - static : encoded in-place.
  - dynamic: encoded at a separately allocated location after the current block.
             - bytes
             - string
             - T[] for any T
             - T[k] for any dynamic T and any k >= 0
             - (T1,...,Tk) if Ti is dynamic for some 1 <= i <= k

- Definitions:
  ```
    - len(a) :  (uint256) number of bytes in a binary string a
    - enc    :  actual encoding binary string:
                ABI_type_Value → enc(ABI_type_Value)
                                 ^^^^^^^^^^^^^^^^^^^
                             len(enc(ABI_type_Value)) depends on:
                                 - ABI_type_Value if type of ABI_type_Value is dynamic.
                                 - ABI_type       if type of ABI_type_Value is  static.
  ```

### Examples.

* Given the contract:
  ```
  pragma solidity >=0.4.16 <0.7.0;

  contract Foo {
    function bar(bytes3[2] memory) public pure {}
    function baz(uint32 x, bool y) public pure returns (bool r) { r = x > 32 || y; }
    function sam(bytes memory, bool, uint[] memory) public pure {}
  }
  ```

* Function call to `FooInstance.baz(69, true)`:
  ```
                                                              0xcdcd77c0: the Method ID. 4 bytes of Keccak("baz(uint32,bool)")
      0x0000000000000000000000000000000000000000000000000000000000000045: uint32 "   69-value" left-padded
      0x0000000000000000000000000000000000000000000000000000000000000001: uint32 " true-value" left-padded

  Function return:
      0x0000000000000000000000000000000000000000000000000000000000000000: uint32 "false-value" left-padded
  ```

* Function call to FooInstance.bar("abc", "def")
  ```
                                                              0xfce353f6: the Method ID. 4 bytes of Keccak("bar(bytes3[2])")
      0x6162630000000000000000000000000000000000000000000000000000000000: bytes3 "abc" left-aligned
      0x6465660000000000000000000000000000000000000000000000000000000000: bytes3 "abc" left-aligned
  ```

* Function call to FooInstance.dave("dave", true and [1,2,3])
  ```
                                                              0xa5643bf2: the Method ID. 4 bytes of Keccak(sam(bytes,bool,uint256[]))
      0x0000000000000000000000000000000000000000000000000000000000000060: location of data-part of  first  dynamic-type  parameter
                                                                          measured in bytes from the start of the arguments block.
      0x0000000000000000000000000000000000000000000000000000000000000001: boolean true
      0x00000000000000000000000000000000000000000000000000000000000000a0: location of data-part of  first    third-type  parameter
                                                                          measured in bytes from the start of the arguments block.
                                                                          first dynamic-argument:
      0x0000000000000000000000000000000000000000000000000000000000000004: length of the byte array in elements
      0x6461766500000000000000000000000000000000000000000000000000000000: contents of the first argument
                                                                          second dynamic-argument:
      0x0000000000000000000000000000000000000000000000000000000000000003: length of the array in element
      0x0000000000000000000000000000000000000000000000000000000000000001: - first entry
      0x0000000000000000000000000000000000000000000000000000000000000002: - second entry
      0x0000000000000000000000000000000000000000000000000000000000000003: - third entry
  ```

### Events ABI Encoding
- Log entries provide the contract's address,
- Up to four topics
- some arbitrary length binary data.

Given an event name and series of event parameters, we split them into two sub-series:

- indexed     parameters: used in Keccak-event-signature to form the topics of the log entry.
- non-indexed parameters: byte array of the event.

In effect, a log entry using this ABI is described as:
```
- contract_address (emiting the event)

- topics[0]: keccak(EVENT_NAME+"("+EVENT_ARGS.map(canonical_type_of).join(",")+")")

- topics[n]: abi_encode(EVENT_INDEXED_ARGS[n - 1])
                        ^^^^^^^^^^^^^^^^^^
                      EVENT_ARGS that are indexed

- data     : ABI encoding of EVENT_NON_INDEXED_ARGS

- if type-byte-length <= 32 → value padded/sign-extended          to 32 bytes is included
- if type-byte-length >  32 → Keccak hash of a special in-place encoded value is included
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                         - This allows applications to efficiently query for keyccak(value)
                           of dynamic-length types
                           but leaves applications unable to decode indexed values they have
                           not queried for
                         - Use the same dynamic value repeated in index and non-index event
                             fields for full functionallity.
```
[[}]]

[[{EVM.101,EVM.events]]
## EVM Events & LOGS

- In the wild, there are three main uses for event logs:
  - As external apps return values, because a transaction does not record a
    method's return values, only the hash confirming the transaction.
  - As a kind of cheaper alternative data storage, as long as the
    contract does not need access to it.
    According to the Yellow paper:
    "...There is no size limit to the data: you will be limited by how
        much Ether you have. (And of course the block gas limit.).The size
        limit of one event is a function of the block's gas limit, which as
        of now tends to be around 3,145,192 (i.e., the first seven digits of
        pi). According to Jonathan Patrick, logging costs 76 gas per byte. So
        I'd assume you could get in around 41kb per log event...."
  - Output evm device sending Event data that DApp clients can subscribe to.

- Emiting an event is a simple EVM logging primitives (log0, log1, ..., log4)
  and a single Solidity

- The EVM logging facility uses different terminologies than Solidity:
  ```
  instruction. e.g.:
  // Solidity event declaration:
  event accountDeposit( address indexed _from, bytes32 indexed _id, uint _value);
  ...
  // Solidity event emission:
  emit  accountDeposit( _from, _id, _value);
  ```

### Event limitations
- There may be at most 3 indexed parameters.
- If the type of an indexed parameter is larger than 32 bytes,
  only the KECCAK256 digest of the data is stored.

- "topics": (event indices): There may be up to 4, exactly 32 bytes each.
  Solidity consumes one topic for the event's signature so only 3 are available
- "data"  : Payload of the event. It may be arbitrary number of bytes.

NOTE: Internally Ethereum nodes use bloom indexes/filters to implement topics and
      topic search in order to speed up search-by-topic.

- External clients must be able to restore current contract state [[{QA.BESTPATTERN]]
  by just reading events.
- Ethereum can return just a very limited information in each
  read-only query. (Up to 7 fields). That means that reports and
  data-analysis must be done on event logs.
- Contract/s state/s must be consulted only by code originated by
  a new transaction trying to update the current state.

- Logs: It is possible to store data in a specially indexed data structure
  that maps all the way up to the block level.
  This feature called 'logs' is used to implement events.
- Contracts  CAN NOT  access log data after it has been created, but they
  can be efficiently accessed from outside the blockchain.
  Since some part of the log data is stored in bloom filters,
  it is possible to search for this data in an efficient and cryptographically
  secure way, so network peers that do not download the whole blockchain
  ("light clients") can still find these logs.
- Logs were designed to be a form of storage that costs significantly
  less gas than contract storage:
  Logs basically[3] cost 8 gas per byte, whereas contract storage costs 20,000 gas per 32 bytes.
  Up to 3 parameters can be indexed. [[}]]

### Event Limits
- Up to 3 indexed fields.
- Up to 7 fields (indexed + non-indexed fields)
- The size limit of one event is a function of the block's gas limit,
  ~ 3_145_192 (first seven digits of pi * 2)
  With a gas costs of 76 gas per byte limit is about 41kb per log event.
  REF: [Storing compressed text in Ethereum transaction logs][http://jonathanpatrick.me/blog/ethereum-compressed-text] 

* Solidity code
  ```
  event EventDepositLog(
      uint256 indexed _market,  ← Up to 3 indexes
      address indexed _sender,    Strings, arrays can  NOT  be used in indexes
      uint256 _amount,            (will be automatically replaced by its hash)
      uint256 _time);
  ```
*  JS Client monitoring logs
  ```
  var myEventMonitor =
    myContract.MyEventNameLog(
       {_sender: userAddress },           // ← filter by idx sender
       {fromBlock: 0, toBlock: 'latest'}  // ← filter by block range^1
    );                                         if ommited observe
                                               "real-time" events
  
  myEventMonitor.watch(                  // ← Start watching
    (err, result) => {
      if (err) { ...    return; }
      console.log(
           "_market:"+result.args._market
         + "_sender:"+result.args._sender );
    }
  )
  ....
  myEventMonitor.stopWatching()          // ← Stop watching
  ```
[[}]]

[[{standards.eea,devops.101,infrastructure.network,doc_has.diagram]]

## e-node management

Extracted from https://github.com/ethereum/devp2p/blob/master/rlpx.md#network-formation

> (P2P Network) NODE Identity:
> each node is expected to maintain a static  secp256k1 private key
> which is saved and restored between sessions.  
> It is recommended that the private key can only be reset manually,
> for example, by deleting a file or database entry.
>
> There are two kinds of connections which can be established.  
> A node can connect to:  
> -- a known peer which has previously been connected to
>    and from which a corresponding session token is available for
>    authenticating the requested connection  
> -- a new peer

- enode uri scheme is used by the Node discovery protocol.
- enode uri scheme can be used in the bootnodes command line option
  of the client or as the argument to suggestPeer(nodeURL) function
  in the JSRE.

- C&P from @[https://github.com/ethereum/wiki/wiki/enode-url-format]
  ```
  enode://6f8516f6144...0 @10.3.58.6:30303?discport=30301
          └───────┬──···─┘  └───┬───┘                └─┬─┘
                  │          DNS NOT trusted         discovery
                  │          Only IP allowed         UDP port
  64-bytes/128 hex-digits
  node ID of the secp256k1
  public key
  ```

### GENERATE PRIVATE KEY AND ENODE ID

* REF:@[https://kobl.one/blog/create-full-ethereum-keypair-and-address/]
* STEP 1) Generate private key
  ```
  $ openssl ecparam -name secp256k1 -genkey -noout | tee >  nodePrivateKey
  -----BEGIN EC PRIVATE KEY-----
  MHQCAQEEIGLW3b7sUpzhb3I4/sLCbakIjfUz6KuBh3Xaox62beJ3oAcGBSuBBAAK
  oUQDQgAEUarn9mq43dODnfxAVcSksAxHsTbrco9FnV0A7Mzqr6guzCQlCCmgXM7k
  Kns43IkR1JfB8mwKkTfOPdykq9nGIg==
  -----END EC PRIVATE KEY-----
  ```
* STEP 2) Show associated public-key in enode format (64 bytes/128 hex digits)
  ```
  $ cat  nodePrivateKey | \
    openssl ec -noout -text  | \      <- Display info with public key ^1
    grep pub -A 5 | tail -n +2 | \    ┐┌ Convert public key to enode expected format
    tr -d '\n[:space:]:' | \          ├┘ Output will be similar to:
    sed 's/^04//'                     ┘  067......(128 hex-digits)......8e06

   ^1 Output will be similar to:
      Private-Key: (256 bit)
      priv:
          00:f4:16:f5:89:3d:60:86:8a:1d:77:4d:2f:74:3b:
          29:53:5b:b9:cb:f9:50:0e:38:39:24:c5:7a:a9:1b:
          b7:d2:b4
      pub:
          04:06:74:34:d5:10:e3:e1:86:a0:39:58:3d:b7:27: <-  Uncompressed Pub. key length must be
          cd:8d:3d:ae:e9:fc:23:8a:6d:54:2e:ca:03:b0:b7:     0x04 prefix + 64 bytes long.
          bc:85:28:df:9b:4d:87:86:61:f3:50:c0:ea:3d:53:
          37:a5:83:1c:94:d8:4e:22:c5:ba:ff:ee:7a:55:e9:
          cb:1f:80:8e:06
      ASN1 OID: secp256k1
  ```
* STEP 3) (Not needed for enode, but can be useful in other configs)
  ```
  $ cat   ${publicAddres} | \
    keccak-256sum -x -l | \     Output will be similar to:
    tr -d ' -' | \              0bed7abd61247635c1973eb38474a2516ed1d884
    tail -c 41                  └─····20 bytes / 40 hex-digits········─┘

    WARN!: if final address looks like
    "0xdcc703c0E500B653Ca82273B7BFAd8045D85a470", it means
    we hashed an empty public key.
    SENDING FUNDS TO THIS ADDRESS WILL LOCK THEM FOREVER!
  ```
[[}]]

[[EVM}]]

[[{EVM,QA.UX]]
# Ethereum Addresses

## Issues

- REF: @[https://ethereum.stackexchange.com/questions/267/why-dont-ethereum-addresses-have-checksums].  
  Initial Ethereum design didn't have support for address checksum.
  thus, a single mistyped digit could make sending to an invalid
  address (loosing all the money).

- **Q**: Was it an oversight that was overlooked by the designers?  
  **A**: the raw hexadecimal string ussually called "Ethereum address"
  wasn't even intended to be the standard way of representing such information.
  containing no checksums. On top of it software can be written
  creating an encoding and string in base 58 with built-in version number
  and checksum, 100% interoperable by silently decoding the new

- NOTE: always include "0x" prefix in front of raw addresses

## ICAP Addresses (IBAN Compatible)
@[https://github.com/ethereum/wiki/wiki/Inter-exchange-Client-Address-Protocol-(ICAP)]

- ICAP: Inter Exchange Client Address Protocol (ICAP)
- compatible with IBAN account formatting.  
  It looks like: `XE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS`.
- (it uses a wider range of alphanumeric characters to save
  space and includes a checksum. similar to Bitcoin)
- ICAP is a fully valid International Bank Account Number (or IBAN).
- It doesn't use hexadecimal addresses. BY the help of ENS
  it can just use an actual human-readable-string to end up
  with something like
  ```
  "XE81ETHXREGJEFFCOLEMAN"
   └──────────┬─────────┘
   XE81 ETH XREG JEFF COLEMAN
   It still matches bank formats!!!
  ```

> Update 2016-02: Vitalik transitional checksumming:
> provides some additional protection against accidental errors
> while remaining backwards compatible with wallets that doesn't support
> the checksum (and will ignore the case differences).

- Ex: Input address '0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826'
  ```
  Output checksumed:'0xCd2a3d9f938e13Cd947eC05ABC7fe734df8DD826'
                       ^             ^     ^  ^^^         ^^
                       └──────────────────────────────────────┘
          letters are in the same corresponding place as a "1" bit
          in the raw binary keccack-256 hash of the address bytes
          are capitalised. Numbers are unchanged.
  ```

- Update: **EIP55 introduces checksum in Ethereum addresses** 
  (Still optional but widely adopted -Metamask,...-)
[[}]]

[[{standards.eip/erc.ENS,QA.UX,PM.TODO.NOW]]
# Ethereum Name Service

* @[https://ens.domains/]

>  No more long addresses: ENS eliminates the need to copy - and worse,
>  type - long hexadecimal addresses ...
>  you'll be able to:
>  - send money to 'aardvark.eth' instead of '0x4cbe58c50480...',
>  - interact with your favorite contract at 'mycontract.eth'
>  - visit a Swarm-hosted site at 'swarmsite.eth'. """

### Ext. Links
- https://github.com/ethereum/EIPs/issues/137 Ethereum Name Service
- https://github.com/ethereum/EIPs/issues/162 Initial ENS Registrar Specification
- https://www.npmjs.com/package/ethereum-ens,  Javascript library
  Nick’s talk on ENS at DevCon 2:
  - https://www.youtube.com/watch?v=pLDDbCZXvTE
  - https://arachnid.github.io/devcon2/#/title  (talk slides)
- https://registrar.ens.domains
- https://docs.ens.domains/en/latest/userguide.html
- Geth implementation: 
  https://github.com/ethereum/go-ethereum/tree/master/contracts/ens
- **GOAL**: resolve human-readable names to Ethereum addresses, Swarm/IPFS hashes, ....
    provide also metadata about names (contracts ABIs, whois info,...)
- ENS operates on a system of  dot-separated hierarchial names called domains,
  with the owner of a domain having full control over the distribution of subdomains.
- Top-level domains (.eth, .test,...) owned by 'registrars' smart contracts
  Anyone may, by following the rules imposed by these registrar contracts,
  obtain ownership of a second-level domain for their own use.
- Secure: ENS is built on smart contracts on the Ethereum blockchain, meaning
  it doesn't suffer from the insecurity of the DNS system.  You can be confident
  names you enter work the way their owner intended.
- Truly Distributed: ENS operates in a distributed fashion for both 
  its infrastructure and governance. Anyone can register a .eth domain 
  name for themselves by participating in an auction process, mediated 
  by the blockchain.
  ```
  TERMINOLOGY
   - domain     : complete, human-readable form of a name; eg, ‘vitalik.wallet.eth’
   - label      : a single component of a domain; eg, ‘vitalik’, ‘wallet’, or ‘eth’
   - label hash : keccak-256(label) eg, keccak256(‘eth’) =
                  0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0
   - node       : namehash function output used to uniquely identify a name in ENS
  ```
- Ex. JS Client code to register:  
  REF: https://github.com/ethereum/go-ethereum/wiki/Contract-Tutorial
  ```
  var name = "MyPersonalDemocracy"
  registrar.reserve.sendTransaction(name, {from: eth.accounts[0]})
  var democracy = eth.contract(daoCompiled.Democracy.info.abiDefinition).
                  at(democracy.address);
  democracy.setup.sendTransaction(registrar.addr("MyFirstCoin"),{from:eth.accounts[0]})
 
  (Wait for the previous transactions to be picked up and then)
 
  registrar.setAddress.sendTransaction(name, democracy.address, true,{from: eth.accounts[0]});
  ```

## ENS Architecture

  ```
  DOMAIN            | REGISTRY CONTRACT                | RESOLVER(S) INTERFACE
  ------            | -----------------                | ---------------------
  - owner (address) | - owned (sub)domains list        | translate name → address
  - resolver        | ----------------                 +-------------------------
  - time-to-live    | + issues subdomains to users  ^1
    for all records |   following logic in contract    | RECORD:
                    | + Set resolver+TTL for domain    | -------
                    | + Transfer ownership             | - type: (Ethereum address, Swarm content hash, ...)
                    | ^1 Only owner of affected domain |          New record types may be defined via EIP
                                                       |          with no need to make changes to the registry
                                                       |          or resolvers
                                                       | - Namehash: 32-byte hash of name (compaq storage+privacy)
                                                       |             defined recursively to preserve the
                                                       |             hierarchal nature
                                                       | ----------
                                                       | - Iface method/s to be implemented by resolver
                                                       |    in order to provide records of that kind.
  ```

## MainNet/... Deployments

* General-purpose resolver implementations are offered for users whose requirements are straightforward,
  such as serving an infrequently changed address for a name.

  ```
  MAINNET DEPLOYMENT: 0x314159265dd8dbb310642f98f50c066173c1259b
                      users may register names under the eth TLD using an auction based registrar.
  ROPSTEN
  TESTNET DEPLOYMENT: 0x112234455c3a32fd11230c42e7bccd4a84e02010
                      users may register names under two top level domains:
                      .eth , auction based
                      .test, allows anyone to claim an unused name for test purposes expiring after 28 days
  RINKEBY
  TESTNET DEPLOYMENT: 0xe7410170f87102df0055eb195163a03b7f2bff4a
                      .test supported
  ```

* Simple ethers.js client using ENS
  ```
   const provider = new ethers.providers.JsonRpcProvider("https://...");
   provider.lookupAddress(addr).then( (resolvedName) => {
     return resolvedName ?? addr;
   })
  ```
[[standards.eip/erc.ENS}]]

[[{101,transaction.101,signature.ecdsa_secp256k1]]
# TRANSACTIONS 

* NOTE: a client Transaction in blockchain is an INTENTION to modify the state of the ddbb.
  It's up to the consensus algorithm to decide when and/or whether the TX will
  be accepted. Client Dapps (web-app/mobile app) must react asynchronously to
  future events. Only when the transaction is inserted in a block (and some future
  works have been mined -in non consensus with statistical finality -) it is considered
  as a valid transaction.
  ```
  ┌ ETHEREUM TRANSACTION ────┐  TX is encoded as   "RLPdata" (nonce,gasPrice,startGas,to,value,data)
  │                          │                   + signature (r, s, v)
  ├──────────────────────────┤
  │ • signature tuple        ←  EOA-wallet valid signature. Signature address must match "from"
  │                          │  sign.tuple == (signature_hash, v, r, s)  ^1 Signature Details
  ├──────────────────────────┤
  │ • EOA-last-nonce + 1     ←  increasing counter avoid replay attacks. Multiple versions of
  │                          │  a TX can be sent with a repeated nonce overwriting pending TX.
  │                          │  Once mined, a submissions will be rejected.
  │                          │
  │ • address sender ("from")←  Must match EOA-address in TX signature, as a proof that from
  │                          │  is actually willing to pay for TX.
  │                          │
┌ │ • address target ("to")  ←  If to == 0            : it means "create contract"
│ │                          │  if to == EOA          : standard wallet-to-wallet payment
│ │                          │  if to == (deployed) SC: Write/Modify/Update Function invocation.
│ │                          │  NOTE: Read-only queries (view/pure functions) do not need a TX
│ │                          │        An standard JSON-RPC with func.params query is enough.
├ │ • byte[]  code("payload")←  if target == 0: compiled bytecode factory for contract.
│ │                          │  Otherwise abi-encoded function call. If encoded function (selector)
│ │                          │  doesn't match any function in S.C. code, its fallback function will
│ │                          │  be invoqued. Otherwise, an exception will be raised.
│ │ • wei ether              ←  ether sent/paid to target/"to"
│ │                          │
│ │                          │
│ │ • wei gasPrice           ←  desired gas price TX signer will pay to miners for  1-unit-of-gas
│ │                          │  when running code.   Used by miners to prioritize TXs .
│ │                          │
│ │ • wei gas                ←  When multiplied by TX.gasPrice == desired max.Ether to pay
│ │                          │  for executing TX. Its purpose is to limit max.
│ └──────────────────────────┘  amount-of-work needed to execute invoqued S.C. code.
│
└ if target == "zero" then:
     step 1: new contract created
     step 2: transaccion.payload executed
     step 3: exec. output stored on-chain at (contract)account.code

  ^1  Signature Details: @[https://medium.com/@angellopozo/ethereum-signing-and-validating-13a2d7cb0ee3]
   - SECP256K1 (one of the ECDSA supported algorithms) is used for signature.
     SECP256K1 Output signature is composed of two integers (r,s) but SECP256K1 ETH/BTC library, however,
     defines the public key as (r, s, v), where v := 0|1. (v is called the recovery id).
     when public key is derived  from the signature  two solutions surge and v is needed.
     - if derived-public-key length is 64 bytes (r,s)   is used.
     - if derived-public-key length is 65 bytes,(r,s,v) is used.
     More info at @[https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v]
     Ethereum makes further adjustments to v in order to prevent replay attack as explained in
     @[https://github.com/ethereum/EIPs/issues/155]]

     · 'ecrecover': Solidity Global Crypto Funct can be used to recover the address given the signature.
       function ecrecover
       (bytes32 signature_hash, uint8 v, bytes32 r, bytes32 s)
       view
       returns (address)   ← Original address associated with the public key (zero on error)
                             Can be used for N/M signatures (See @[#eip-191])

     - NOTE: The use of Curve25519 with Schnoor signing scheme (Ed25519) is under discussion

     - NOTE: Only Externally Owned Accounts can sign transactions. EIP-1271 offers a
       "abstraction" of signature as described in @[eip-1271].
  ```

*TX SENDER-to-MINER PAYMENT RULES:
 ```
  - If ( execution gas < transaction.gas ) { Refund rest to sender }
  - If ( execution gas > transaction.gas ) {
      · out-of-gas exception triggered.
      · modifications made to the state in current call frame reverted.
      · TX is still mined, and weis lost BUT there is no state change.
    }
 ```
* BLOCK VALIDATION ALGORITHM (CONSENSUS)
  ```
  - Check if previous block referenced exists and is valid
  - Check ( last_block.timestamp < new_block.timestamp < lst_block.timestamp + 15 minutes )
  - Check block-number, difficulty, transaction root, uncle root and gas limit
    (various low-level Ethereum-specific concepts) are valid.
  - Check that proof-of-work is valid.
  - Let S[0] be the STATE_ROOT of the previous block.
  - Let TX be the block's transaction list, with n transactions. For all "i" in
    0,...n-1, set S[i+1] = APPLY (S[i],TX[i]). If any application returns error, or
    if the total gas consumed in the block up until this point exceeds consensus
    constant BLOCK.GASLIMIT, return error.
  - Let S_FINAL be S[n], but adding the block reward paid to the miner.
  - Check if S_FINAL == STATE_ROOT.
  ```
[[transaction.101}]]

## TX HASH vs TX Receipt [[{transaction.101,EVM.101]]

- When a transaction is signed and sent for mining, an inmutable
  TX-hash is created, that will be used as TX unique ID.
- When the transaction is finally mined, the TX receipt is created.
  It includes the original txHash, plus TX mining information:
  ```
  receipt: {
    transactionHash  : '0xc9f5...32bytes', <- Inmutable hash created before mining
    cumulativeGasUsed: 28719,        <- Note
    gasUsed          : 28719,
    status           : false,        <- The TX reverted. Note. It was mined, and
                                        ethers spent, but not with the expected
                                        "happy-path" behaviour.
    transactionIndex : 0,            <- order of TX in its block
    blockNumber      : 440,
    blockHash        : '0x...32bytes...',
    from             : '0x05..20bytes address',
    to               : '0x40..20bytes address',
    logsBloom        : '0x00...'   , <- Bloom index of events emitted by the TX.
                                        (empty when TX is reverted)
  }
  ```
- NOTE: When a new TX has not yet being mined it can be resend with
  same TX.nonce and different max-gas and gas-price generating a new TX-hash.
  The first TX to be included will invalidate any concurrent one since
  the TX.nonce will not be valid and discarded automatically by network nodes.
  ```
  { tx: '0xf47f...41c',
    receipt:
     { transactionHash: '0x1234....',   <- Use it to identify MINED transaction.
       blockHash: ...,
       logs: [...],
       status: '0x01',
       gasUsed: 298373,
       ...
     },
    logs: [...]                         <- logs == "emitted events"
  }
  ```
[[transaction.101}]]

* Offline/Online TX signing [[{wallet.101,transaction.signature]]
  ```
    OFFLINE TX SIGNING (RECOMENDED)           |    "ON-LINE" TX SIGNING (LESS SECURE, DISCOURAGED)
                                              |
The "raw" TX must be signed first             | - An Ethereum node (geth, parity,...) will be used.
by an offline (js,python,hardware wallet,...) | - It forces to have the wallet on the client node and
client using a private key ("wallet")         |   unlock the account. Unless the wallet is hardware
with or without connection to any ethereum    |   secured is usually less safe than client signature
network node.                                 |   (but offline clients can also be insecure or
The signed TX is then sent to the network.    |   hacked)
  ```
[[}]]

## Clef(signer) middleware [[{wallet.cloud,security,doc_has.diagram,PM.TODO]]
@[https://github.com/ethereum/go-ethereum/blob/master/cmd/clef/tutorial.md]

- See also EthSigner (EthSigner)[./EthSigner-wallet/signer-middleware]
- Sign TX and data (data "==" swap/swarm), designed
  as an (eventual) replacement for Geth's account management.
- DApps/Middleware can  send data/TX to Clef, which will
  then provide the user with context and asks for permission
  to sign the content.
  If the users grants the signing request, Clef will send the
  signature back to the DApp.
- Programmatic rules for automated (batch) transactions.        [[{architecture.batch]]
  (e.g. Clique signer, Raiden relay, Swarm exchange, etc).
  Clef solves this via an encrypted key-value store and an ingenious
  rule engine! Instead of prompting the user to confirm each and every
  request via a passphrase entry, we can permit Clef to sign on our
  behalf by storing our passphrase in its encrypted database.
  This will only allow passwordless signing, but still needs
  manual confirmation!  
  -- JS rule file: as requests arrive it decides to
    auto-confirm, auto-reject, or forward to manual confirm.
    JS rules have access to full request and can also store
    arbitrary data in a key-value store for persistence. Ex:
    ```
      function ApproveSignData(req) {
        if (req.address.toLowerCase() == "0xd9....") {
            if (req.messages[0].value.indexOf("bazonk") >= 0) {
                return "Approve"
            }
            return "Reject"
        }
        // ... continue with manual processing
      }
    ```
                                                                    [[}]]
REF: @[https://hackmd.io/@ethswarm/SyrP04XdI] (2020-04)

-  looks dead  but some work is happening again (https://github.com/ethereum/clef-ui).
- documentation is unclear on what works but testing showed it works surprisingly well
- can sign arbirtrary data.
- seems to have quite a few undocumented features
- only allows function signatures from the 4bytes directory
  (swap was not yet there)
-  go-ethereum already has code for using clef as a signer
-  managed to deploy chequebooks and sign cheques :
 @[https://github.com/ralph-pichler/swap-clef-test]
-  Tightly integrated with geth:
   Adding any crypto functions requires modifying the main
   go-ethereum wallet interface:
  - modify keystore backend.
  - modify the hw wallet and smart card backends
[[}]]

## EthSigner middleware [[{wallet.cloud,security,doc_has.diagram]]

- REF: @[https://hackmd.io/@ethswarm/SyrP04XdI] (2020-04)
  @[https://docs.ethsigner.pegasys.tech/en/latest/]
- used as signer middleware, replaces eth_sendTransaction
- does NOT replace eth_signData (and alike).
- hacks for eth_signData seem possible (based on blog posts),
  but even that doesn’t allow arbitrary data
- does not work well with the design of go-ethereum based
  contract interaction.
- primarily for enterprise (Azure Key Vault, Hashicorp,...)
  ```
      eth_sendTransaction,    eth_sendRawTransaction,
      eea_sendTransaction     eea_sendRawTransaction
               ·                    ·
               v                    v
  │Dapp│     <····> │EthSigner│ <······> │Ether │
  (Web3j/            Signs TXs           │Client│
  Web3j-eea)           · ^
                       · ·
                       v ·
                    V3 Keystore,
                    Hashicorp Vault,
                    Azure Key Vault,
                    ...
  ```
[[}]]

## offline sign with Azure Vault  [[{wallet.cloud,signature.ecdsa_secp256k1,security,PM.TODO]]

- REF: @[https://tomislav.tech/2018-02-05-ethereum-keyvault-signing-transactions/]
[[}]]

## Meta-transactions: [[{wallet.metamask,EVM.gas,QA.UX.wallet,transaction,PM.TODO]]
@[https://defirate.com/meta-transactions/]

- Purpose: Isolate final Dapp users from gas payments.
- meta transactions allow users to interact with a public
  blockchain without paying a transaction fee:
  - Users no longer have to understand the inner workings  [[{QA.UX]]
    of public blockchains and market dynamics for TX fees. [[}]]

- At its core, they are NEARLY IDENTICAL TO REGULAR NETWORK TXS
  BUT WITH THE ADDITION OF A PROXY CONTRACT, known as "relayer".
- Users still use their signature to sign TXs, then
  the signed TX is now managed by the relayer who
  pays the gas and sends the transaction to the
  receiving address.
[[}]]

## EVM: Calls vs TXs [[{doc_has.comparative,101,EVM.101]]

Imagine a solidity code similar to:
  
```
contract Voting {
  mapping (uint /* proposal */=> uint /* total votes */) countMap;
  event totalForProposal(uint total)
  ...
  function vote(uint proposalID)
  returns (uint total) {
     countMap[proposalID] = votes[proposalID]++;
     unit   result  = countMap[proposalID];
     emit totalForProposals(  result )
     return   result
  }
  ...
}
```
  
This is function will modify the state of the blockchain
(it's not a "view"  or "pure" function in Solidity parlance).
  
  Calling this function from "outside" the blockchain is done through
a criptographically signed transaction. The module (mobile wallet,
middleware,...) sending the signed transaction will wait indefinetely
while the TX is first propagated through the network to a mining node
, then mined (the miner executes the contract) and the TX receipt
received later on in a mined block).
  
The only way tthis external module has to fetch the result of the
function is through asynchronous events.
  
 This same function can be called in the mid of another transaction
when another method indirectly call it. This time, and that's why
the solidity code includes an "emit totalFroProposals..." as to
allow the module to be notified of the result.
  
  This function can also be part of a bigger execution path an called
in the mid of an started transaction. The EVM will already be executing
some method that in turn calls this "vote" function as part of a
normal program execution. When the "vote" function returns it has
access to the returned result since it has been placed on the EVM
stack. The emitted event is ignored (actually will be included in
the block after mining to be propagated back to any listening
application).

  Note also that we can have read-only functions ("view" or "pure"
in Solidity parlance"). In that case both an external module or
an internal function can fetch the returned value inmediatelly
(there is no TX propagation or mining and all the needed data
is local to the closest ethereum node -geth, parity,...-).
The javascript web3js (or java web3j or ...)
In the case of the external module through an RPC call, and in
the case of an internal EVM function through the (much faster)
EVM stack.
[[}]]

# Generic signatures and signatures standards: [[{signature.standards,use_case.identity,standards.eip/erc.191]]
* While transaction signing is the first use-case for digital signature, other use-cases are well
  supported by the Ethereum ecosystem thanks to EVM support for signature recovery during contract 
  execution.

[[{signature.standards.EIP191,wallet.standards,use_case.legal,,QA.UX,PM.WiP]]
## EIP-191: Signed Data Standard 

* @[https://eips.ethereum.org/EIPS/eip-191]
* @[https://github.com/ethereum/EIPs/issues/191]
* @[https://medium.com/mycrypto/the-magic-of-digital-signatures-on-ethereum-98fe184dc9c7]

### (PRE EIP-191) "PERSONAL_SIGN" FORMAT:

* first implemented by Geth and is still the most common. (2020-10-02)

  ```
  | STEP 1)
  |    ┌─ RLP encoded TXs never start with 0x19, so we used it now to make 
  |  ┌─┴┐ it clear it is NOT RLP TX data.
  |  ·  ·
  | "\x19Ethereum Signed Message:\n"   + length(message) + message <·· Non hashed version
  | "\x19Ethereum Signed Message:\n32" + Keccak256(message)        <·· hashed version
  | └─────────────┬─────────────────┘
  |        message prefix
  |
  | STEP 2) full message (including the prefix) is then hashed again, and
  |         the output-data is signed.
  ```

* PROS: works fine for proof-of-ownership.
* CONS: Not enought for other use-cases. e.g:
  ```
  | user_A   -> contractX: signed_msg01
  | HACKER!! -> contractY: copy of signed_msg01 <·· replay attack!!!
  ```

* EIP-191 SIGNED DATA STANDARD:
  ```
  | 0x19 <1 byte version> <version specific data> <data to sign>
  |      └┬─────────────┘
  |       ▸ 0x00: Data with "intended validator", e.g.: The address of the contract. 
  |               => Contract receiving the signature must re-calculate the hash
  |                  and fail if it doesn't match its own address.
  |       ▸ 0x01: Structured data, as defined in EIP-712.
  |       ▸ 0x45: Regular signed messages, The current "personal_sign"
  ```

* Several multisignature wallet implementations have been created  [[{signature.multisignature}]]
  which accepts presigned transactions (chunk of binary signed_data,
  along with signature (r, s and v) ).<br/>
    Interpretation of the signed_data has not been specified, leading to
  several problems.
  - Standard Ethereum transactions can be submitted as signed_data.
  - An Ethereum transaction can be unpacked, into:
    - `RLP<nonce, gasPrice, startGas, to, value, data>` (called RLPdata),
    - r, s and v.
  - Multisignature wallets have also had the problem that a presigned
    transaction has not been tied to a particular validator, i.e a specific
    wallet. Example:
    ```
    · Users A, B and C have the 2/3-wallet X
    · Users A, B and D have the 2/3-wallet Y
    · Users A and B submites presigned transaction to X.
    · Attacker sends presigned transactions to Y (instead of X).
    ```
* Related code:
  <https://github.com/0xsequence/erc-1155/blob/master/SPECIFICATIONS.md#meta-transactions>
  NOTE: The byte version looks to be similar but-different to the one in 191:
  ```
  0x00:Illegal,  0x01:EIP712, 0x02:EthSign, 0x03:WalletBytes 0x04:WalletBytes32
  ```
[[signature.standards.EIP191}]]

[[{signature.standards.EIP4361,QA.UX,security.AAA,]]
## EIP-4361: Using EIP-191 for Offchain client Auth 

* <https://github.com/spruceid/EIPs/blob/eip-4361/EIPS/eip-4361.md>
* <https://ethereum-magicians.org/t/eip-4361-sign-in-with-ethereum/7263/2>

* SCENARIO:
  ```
  "https://service.org" wants to authenticate user through its Ethereum account 0xc02aaa39...

    ┌─ Example message to be signed ────────────────────────────────────────┐
    │ I accept the ServiceOrg Terms of Service: https://service.org/tos     │
    │                                                                       │
    │       URI: https://service.org/login                                  │
    │   Version: 1                                                          │
    │  Chain ID: 1                                                          │
    │     Nonce: 328917                                                     │
    │ Issued At: 2021─09─30T16:25:24Z                                       │
    │ Resources:                                                            │
    │ - ipfs://bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq/ │
    │ - https://example.com/my_web2_claim.json                              │
    └───────────────────────────────────────────────────────────────────────┘
    - For EOAs              verification method in EIP-191  MUST be used.
    - For Contract Accounts verification method in EIP-1271 MUST be used.
  ```
[[signature.standards.EIP4361}]]

* Related: Using wallets to sign documents / forms offchain <br/>
  (REF: <https://www.youtube.com/watch?v=vhUjCLYlnMM&ab_channel=ArturChmaro>
  ```
  | import { ethers } from "ethers";
  | const signMessage = async ( { setError, message }) => {
  |        try {
  |    console.log( { message } );
  |    if (!window.ethereum) { throw new Error("No crypto wallet found"); }
  |    await window.ethereum.send("eth_requestAccounts");
  |    const provider = new ethers.providers.Web3Provider(window.ethereum);
  |    const signer = provider.getSigner();
  |    const signature = await signer.signMessage(message);
  |    const address = await signer.getAddress();
  |    return { message, signature, address }
  |        } catch (err) {
  |    setError(err.message);
  |       }
  |   }
  | );
  |
  | const verifyMessage = async ( ({ message, address, signature }) => {
  |     try {
  |   const singerAddr = await ethers.utils
  |                      .verifyMessage(message, signature);
  |   return (signerAddr == address );
  |     } catch(err) {
  |   console.log(err);
  |   return false;
  |     }
  | });
  ```
* Related: Legally Binding Signatures EIP 5289 [[{signature.standards.EIP5289,use_case.legal,standards.eip/erc.5289}]],
  <https://eips.ethereum.org/EIPS/eip-5289>
  proposed standard that allows smart contracts to be legally binding by
  providing IPFS links to legal documents and ensuring that the users of
  the smart contract have privity with the relevant legal documents.

  To request that certain documents be signed, revert with the following reason:
  ```
  | string.concat("5289:",
  |     libraryAddress1, "-", documentId1OfAddress1, "-", documentId2OfAddress1 ",",
  |     libraryAddress2, "-", documentId1OfAddress2, "-", documentId2OfAddress2 ","
  |     ...)
  |  Revert example: "5289:1-1-2,hEl/0-7bA"
  ```
  *  Signing a Document:
     When a signature is requested by (revert captured by wallet), wallets
   MUST call legalDocument and fetch the file off of IPFS, and render
   that file to the user. If the user agrees, the wallet MUST call
   signDocument. Using a form of account abstraction is RECOMMENDED.
[[signature.standards.EIP5289}]]

[[{signature.standards.EIP712,QA.UX.wallet,wallet.metamask,wallet.lattice1,PM.TODO]] @[eip712]
## EIP-712 (Typed human-friendly signing)

* "Ethereum typed structured data hashing and signing"
  <https://eips.ethereum.org/EIPS/eip-712>

   ```
   | BEFORE EIP-712                  AFTER EIP-712
   |
   | ┌─ Wallet Display: ──────┐       ┌─ Wallet Display: ──────┐
   | │  signature required    │       │  signature required    │
   | ├────────────────────────┤       ├────────────────────────┤
   | │ Message:               │       │ Message:               │
   | │ 0x7123Af317dE20.....   │       │     to: 0x7123Af317d...│
   | │ ....234718a0fe01e...   │       │ amount:                │
   | │ ...a0fe0347117d        │       │   noce:                │
   | │                        │       │                        │
   | ├────────────────────────┤       ├────────────────────────┤
   | │ [Cancel]       [Sign]  │       │ [Cancel]       [Sign]  │
   | └────────────────────────┘       └────────────────────────┘
   |
   |  As in OAuth/OIDC, a domain must also be specified. e.g:
   |  ┌── Domain: ──────────────────────────────────┐
   |  │              name: "Decentralised Exchange" │
   |  │ verifyingContract: "0x24242...."            │
   |  │           version: "1"                      │
   |  │              salt: "f12da....."             │
   |  └─────────────────────────────────────────────┘
   ```

### How to implement EIP-712:
* <https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26>

* Related:
  - Lattice 1 GridPlus Hardware Wallet:
    <https://blog.gridplus.io/latice1-firmware-v0-10-6-da18ec10f5b>
    1st with Native EIP-712 Support for Use with Uniswap V3, Polygon, and More!<br/>
    ```
    ... When Uniswap V3 launched, liquidity providers were unable to
     migrate their positions because Uniswap uses a new message type
     (EIP-712) which is not yet supported on legacy hardware wallets using
     MetaMask and their assets were stuck. Not an issue for Lattice1
     owners... Competitors have publicly shared that even when they do
     support the feature, they will not be using their device's secure
     enclave and will instead create hashes in your computer's web
     browser. Never use your hardware wallet to blindly sign unknown
     hashes.
    ```
* Reference Implementation/Ussage @ 0xProject:
  ```
  | https://github.com/0xProject/0x-monorepo/blob/development/
  | ├─ contracts/utils/contracts/src/LibEIP712.sol
  | ├─ contracts/utils/contracts/test/TestLibEIP712.sol
  | ├─ contracts/coordinator/contracts/src/libs/LibEIP712CoordinatorDomain.sol
  | ├─ contracts/exchange─libs/contracts/src/LibEIP712ExchangeDomain.sol
  | ├─ contracts/exchange─libs/contracts/test/TestLibEIP712ExchangeDomain.sol
  | ├─ contracts/exchange─libs/contracts/test/TestLibOrder.sol
  | ├─ contracts/exchange─libs/contracts/test/TestLibZeroExTransaction.sol
  | ├─ contracts/zero─ex/contracts/src/fixins/FixinEIP712.sol
  | ├─ ...
  ```
[[signature.standards.EIP712}]]

[[{solidity,signature.multisignature,PM.WiP,QA.UX]]
## Checking Signatures On-Chain

- ECDSA signature == 65 byte array ( v (1), r (32), s (32) ).
  - web3.eth.sign (and others) can be used to insert extra signatures
    in a new transaction (other than the signed transaction itself)
  - OpenZepellin "recover(bytes32 hash, bytes signature) → address" allows
    to recover the original public address and apply any dessired
    business logic.  (e.g, deny transaction if less than N correct
    signatures are in place, ...)
    <https://docs.openzeppelin.com/contracts/2.x/api/cryptography#ECDSA>

  NOTE:  Most wallets will hash the data to sign and add the prefix
    '\x19Ethereum Signed Message:\n'. When attempting to recover
    the signer of an Ethereum signed message hash, 'toEthSignedMessageHash'
    is preferred.
[[}]]

[[{signature.multisignature,QA.UX,PM.TODO]]
## EIP-1271. Verify signatures comming from contracts

* <https://github.com/ethereum/EIPs/issues/1271>
- It should be implemented by contracts which desire to sign messages
 ("wallets", DAOs, multisignature wallets, etc.).
  Applications will call this method if signer is a contract (vs EOA).

- External "Dapps" can allow users to sign off-chain messages
  vs  directly requesting users to do an on-chain transaction.
  - Examples include decentralized exchanges with off-chain orderbooks
    like "0x" and "etherdelta

- This proposal outlines a standard way for contracts to verify if a
  provided signature is valid when the account is a contract:

  - this is more than just validating signatures. We are actually
  asking the question:
  ```
  "GIVEN THIS ACTION, DOES THE CALLER HAVE THE ABILITY TO IT,
   GIVEN THIS PROOF?"
  ```
  - 'isValidSignature':
     Implementations can call arbitrary methods to validate a given signature.
    which COULD BE CONTEXT DEPENDENT (e.g. time based, state based,...).
    SIGNATURE SCHEME DEPENDENT (e.g. ECDSA, multisig, BLS), etc.
[[}]]
[[signature.standards}]]

[[{EVM.gas_price,101,transaction,EVM.events,privacy.zksnark,scalability.consensus]]
# TX Gas Price

* REFs
  * <https://github.com/ethereum/wiki/wiki/Design-Rationale#gas-and-fees>
  * <http://www.ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html?highlight=gas#what-is-gas>

## Gas rationale
* Gas protect against DoS attacks and buggy nodes, EVMs, and/or smart-contracts.
* Price cost applies to public network and (optionally) to private/consortium networks.
  NOTE: private/consortium networks will still be constrained to
        gas limits even when gas price is ZERO. [TODO]: Recheck
* TXs will fail if the consume too much gas ("CPU" or storage)
  but users will not loose any ethers when price is set to ZERO.

## See gas consumption per OpCode

* <https://github.com/ethereum/pyethereum/blob/master/ethereum/opcodes.py>
  ```
  | # NON-OPCODE GAS PRICES
  | GDEFAULT           =     1
  | GMEMORY            =     3
  | GQUADRATICMEMDENOM =   512  # 1 gas per 512 quadwords
  | GSTORAGEREFUND     = 15000
  | GSTORAGEKILL       =  5000
  | GSTORAGEMOD        =  5000
  | GSTORAGEADD        = 20000
  | GEXPONENTBYTE      =    10 # cost of EXP exponent per byte
  | GCOPY              =     3 # cost to copy one 32 byte word
  | GCONTRACTBYTE      =   200 # one byte of code in contract creation
  | GCALLVALUETRANSFER =  9000 # non-zero-valued call
  | GLOGBYTE           =     8 # cost of a byte of logdata
  |
  | GTXCOST            = 21000 # TX BASE GAS COST
  | GTXDATAZERO        =     4 # TX DATA ZERO BYTE GAS COST
  | GTXDATANONZERO     =    68 # TX DATA NON ZERO BYTE GAS COST
  | GSHA3WORD          =     6 # Cost of SHA3 per word
  | GSHA256BASE        =    60 # Base c of SHA256
  | GSHA256WORD        =    12 # Cost of SHA256 per word
  | GRIPEMD160BASE     =   600 # Base cost of RIPEMD160
  | GRIPEMD160WORD     =   120 # Cost of RIPEMD160 per word
  | GIDENTITYBASE      =    15 # Base cost of indentity
  | GIDENTITYWORD      =     3 # Cost of identity per word
  | GECRECOVER         =  3000 # Cost of ecrecover op
  |
  | GSTIPEND           =  2300
  |
  | GCALLNEWACCOUNT    = 25000
  | GSUICIDEREFUND     = 24000
  ```

* The most expensive operations by far are storage ones 
  ```
  ┌─────────────┬───────┬────────────────────────────────────────────┐
  │Operation    │   Gas │ Remark                                     │
  │Name         │ Spent │                                            │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │step         │     1 │ default amount per execution cycle         │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │stop         │     0 │ free                                       │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │suicide      │     0 │ free                                       │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │self-destruct│-24000 │                                            │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │sha3         │    20 │                                            │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │sload        │    20 │ get 32-bytes from permanent storage        │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │sstore  op   │   100 │ put 32-bytes into permanent storage        │
  │             │       │ (+ ~ 20000 by setting     zero → non-zero) │
  │             │       │ (- ~ 10000 by setting non-zero → zero)     │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │balance      │    20 │                                            │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │create       │   100 │ contract creation                          │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │call         │    20 │ initiating a read─only call                │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │memory       │     1 │ every additional word when expanding memory│
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │txdata       │     5 │ every byte of data or code for a TX        │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │transaction  │   500 │ base fee transaction                       │
  ├─────────────┼───────┼────────────────────────────────────────────┤
  │contract     │ 53000 │ changed in homestead from 21000            │
  │  creation   │       │                                            │
  └─────────────┴───────┴────────────────────────────────────────────┘
  ```
* Most instructions costs 3~10 gas.
* Gas costs are set somewhat arbitrarily, and will change/adapt in the future.
* As costs change, compilers will make different choices.

## TX cost

* <https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603>
  ```
  ✓ 21000 gas per TX (fixed cost)
  ✓     4 gas per     zero-byte of data|code
  ✓    68 gas per non-zero-byte of data|code
  WARN : Small negative numbers are mostly 1s, 
         costing quite a lot of gas.
  ```

[[{EVM.EVENTS]]
## LOGGING (INMUTABLE EVENTS) GAS COSTS

@[https://blog.qtum.org/how-solidity-events-are-implemented-diving-into-the-ethereum-vm-part-6-30e07b3037b9]
* gas costs for evm logging primitives depends on number of topics (indexes)
  and payload length:
  (constants are defined in protocol_params)
  ```
    ✓   8 gas per byte in a LOG operation's data LogDataGas
    ✓ 375 gas per LOG                            topicLogTopicGas
    ✓ 375 gas per LOG operation                  LogGas
    ✓   3 gas per byte of payload                MemoryGas

    ✓ ??? gas per data in calldata if source log
          data comes from mined TX
          (4 gas per zero-byte, 64 per non-zero-byte)

      HINT : event with all non-zero bytes called from external
             TX it is still a lot cheaper than storage.
      • 3200 no-zero-bytes log gas   TX FIXED COST(log or sstore) :
        (external signed TX sent from wallet/client dApp)

        Concept                     Unit ^         Sub
                                    Unit-cost      Total
        ─────────────────────────────────────────────────
        TX cost                    |   1 * 21000 |  21000
        external tx non-zero-bytes |3200 *    68 | 217600 ← TIP: optimize non-zero-bytes
        TX data|code byte          |3200 *     5 |  16000
         ────────────────────────────────────────────────
                                           TOTAL   254600

      • 3200 no-zero-bytes log gas bill:
        Most gas cost is TX data, not log ops itself.

        Concept                     Unit *            Sub
                                    Unit-cost       Total
        ─────────────────────────────────────────────────
        TX FIXED COST              |   1 * 254600| 254600 ← Most gas cost is TX data,
        log-data-cost              |3200 *      8|  25600   TIP: optimize input data
        memory usage cost          |3200 *      3|   9600
        log call cost              |   1 *    375|    375
        ─────────────────────────────────────────────────
                                           TOTAL   290175 ~ 7.8 times cheaper

      • 320 no-zero-bytes sstore bill:
        Concept                     Unit *            Sub
                                    Unit-cost       Total
        ─────────────────────────────────────────────────
        TX FIXED COST              |   1 * 254600| 254600
        memory usage cost          |3200 *      3|   9600
        sstore op                  | 100 *    100|  10000
        sstore zero → non-zero     | 100 *  20000|2000000
        ─────────────────────────────────────────────────
                                           TOTAL  2274200
      • The real reason is for lower prices is that log data is NOT
        really stored as blockchain status. Logs, in principle, can
        be recalculated on the fly as necessary.
        TX validation (by miners) will not access past logs.

      • Network as a whole does not bear the cost of logs.
        Only API service nodes need to actually process, store,
        and index the logs.
      • cost structure is kept  minimal t  prevent log spammin  .
  ```
[[EVM.EVENTS}]]

[[{]]
## gas price calc

* WARN: Extracted from <https://medium.com/hackernoon/costs-of-a-real-world-ethereum-contract-2033511b3214><br/>
    """(2017–08–23) The median gas price at the time of writing this article was,
    and continues to be, in the realm of 20 Gwei. This is far greater than the
    typical average and safe-low found on EthGasStation (4 and 0.5 Gwei respectively).
    The median is so high because of bad gas-price defaults found in many wallets.
    I highly recommend using EthGasStation's average gas-price or lower in order
    to not pay high fees and to help drive down the market rate for gas-price."""

* <http://ethgasstation.info/calculator.php>
  Gas (defined in the [Ethereum-Yellow-Paper]):
  - virtual pricing mechanism for TXs (ether transfer and smart contracts controlled)
  - Protect against Denial of Service attacks and resource-consumption attacks
    by compromised, malfunctioning or malicious nodes.
  - EnterpriseEthereum provides additional tools to reduce security risks, such
    as more granular permissions for actions in a network or node-entrance
    firewalls and allowed/denied list of valid TX signers

  ```
  | Taking a reference ratio of 200€/ether:
  |   Fixed Costs:
  |    └ TX gas price: 21000 gas/tx
  |      ┌──────────┬─────────────────┬────────┐
  |      │ gasprice │ total gas price │ total €│
  |      ├──────────┼─────────────────┼────────┤
  |      │  1gwei   │ 21000 x  1gwei  │ 0,0042 │
  |      │ 20gwei   │ 21000 x 20gwei  │ 0,0840 │
  |      └──────────┴─────────────────┴────────┘
  |
  |   Internal Storage Costs:
  |   └ 32bytes Contract storage: 20000 gas
  |     ┌──────────┬─────────────────┬────────┐
  |     │ gasprice │ total gas price │ total €│
  |     ├──────────┼─────────────────┼────────┤
  |     │  1gwei   │ 21000 x  1gwei  │ 0,004 €│
  |     │ 20gwei   │ 21000 x 10gwei  │ 0,080 €│
  |     └──────────┴─────────────────┴────────┘
  |   └ Total TX cost for 64 bytes  (32bytes from debitor to creditor account)
  |     ┌──────────┬─────────┐
  |     │ gasprice │ total € │
  |     ├──────────┼─────────┤
  |     │  1gwei   │ 0,0122  │ 0,0042 (TX fix cost) + 2 x 0,0040 (32bytes Contract storage)
  |     │ 20gwei   │ 0,2440  │
  |     └──────────┴─────────┘
  |
  |   LOGS-COST:
  |   └ ┌───────┬───────┬────────┬────────────┬────────────────────────────────────┐
  |     │size in│ num.of│ gas    │total       │  total €                           │
  |     │  bytes│ topics│ price  │gas price   │  (200€/eth)                        │
  |     ├───────┼───────┼────────┼────────────┼────────────────────────────────────┤
  |     │       │       │        │            │  LOG Cost   TX Cost                │
  |     │       │       │        │            │ ┌───────┐   ┌────┐                 │
  |     │  1024 │   3   │ 1gwei  │9692 x 1gwei│ 0,0019384 + 0,0042 € = 0.0061384 € │
  |     │   512 │   3   │ 1gwei  │5596 x 1gwei│ 0,0011192 + 0,0042 € = 0.0053192 € │
  |     │   256 │   1   │ 1gwei  │2798 x 1gwei│ 0,0005596 + 0,0042 € = 0.0047596 € │
  |     │   128 │   0   │ 1gwei  │1399 x 1gwei│ 0,0002798 + 0,0042 € = 0.0044798 € │
  |     ├───────┼───────┼────────┼────────────┼────────────────────────────────────┤
  |     │       │       │ 20gwei │9692 x20gwei│ 0,0387680 + 0,0840 € = 0.1227680 € │
  |     │   512 │   3   │ 20gwei │5596 x20gwei│ 0,0223840 + 0,0840 € = 0.1063840 € │
  |     │   256 │   1   │ 20gwei │2798 x20gwei│ 0,0111920 + 0,0840 € = 0.0951920 € │
  |     │   128 │   0   │ 20gwei │1399 x20gwei│ 0,0055960 + 0,0840 € = 0.0895960 € │
  |     └───────┴───────┴────────┴────────────┴────────────────────────────────────┘
  |                               └┬─┘
  |                                └─────────────────────────────────────────────┐
  |      NEW LOG GAS       LOG BYTES GAS       TOPIC ("INDEX")GAS              TOTAL GAS
  |     ┌───────────┐ ┌────────────────────┐ ┌────────────────┐                 ┌┴─┐
  |     (375 gas/LOG)+(8gas/byte x 1024byte)+(375gas/topic * 3) = 375+8192+1125=9692
  |     (375 gas/LOG)+(8gas/byte x  512byte)+(375gas/topic * 3) = 375+4096+1125=5596
  |     (375 gas/LOG)+(8gas/byte x  512byte)+(375gas/topic * 1) = 375+2048+ 375=2798
  |     (375 gas/LOG)+(8gas/byte x  128byte)+(375gas/topic * 0) = 375+1024     =1399
  |                    ^^^^^^^^^^
  |                >>  This means 256 gas for 32bytes, version 20.000 gas for 32 bytes
  |                    in internal storage.   78.125 times cheaper per byte !!
  |                                            FIX TX cost not included
  ```
[[}]]

[[{PM.RISKS]]
## Watch Out default gas price!!!

* Extracted from stack-overflow:
  ```
  Q: """ETH (to USD) price has gone from ~8 to ~90 USD in 6 months
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        I see that most people are still using default gas price of
        2e10 wei/gas. Shouldn't we be lowering the gas prices per TX
        to account for this price change?
        ... I intend to drop fee gas price by 75%. Will TXs still be
        mined in a timely fashion?"""
  A: ...Absolutely. Everyone should. There's a great site here that
        will help you understand gas and gas prices.
       It's called Ethereum Gas Station: http://ethgasstation.info/
       They just recently made this post which explains something they
       call the Safe Gas Price:
     <https://medium.com/@ethgasstation/the-safe-low-gas-price-fb44fdc85b91>
  ```
[[}]]

[[EVM.gas_price}]]

[[{scalability,EVM.gas_price]]
## EIP 1559 Trying to avoid Gas price peaks. 

* <https://blog.ethereum.org/2020/06/16/eth1x-1559/>
- Problem Context:
  * TX gas price can spike when block ussage is close to full.
  * wallets trying to pay "fast" (vs waiting for TX demand/fees
    to go down) might end up paying ridiculous fees.
    (Supported by Besu and other clients).
- EIP-1559 dramatically alter how gas fees are calculated.
  * TX fees broken into two categories:
    * **base fee**:  predictable  based on how TX number in last block.
      * base fee will be burned (removed from circulation)  vs going
        into miner's pockets.
      * base fee dynamically adjust so that the overall gas usage in
        a block moves toward the current limit of 10 million gas.
    * **Miner tip**: added at will by TX users in order to incentivize
      miners to include their TX in mined block.

* WARN: EIP-1559 does NOT reduce TX fees
[[}]]
